%!TEX root = htm.tex
\subsection{Progressive HyTM with linear}
\label{sec:hytm1}
%
\input{prog-fp-sp}
%
For every t-object $X_j$, our implementation maintains a base object $v_j\in \mathbb{D}$ that stores the value of $X_j$
and a \emph{sequence lock} $r_{j}$. The sequence lock is an unsigned integer whose LSB bit stores the \emph{locked} state.
Specifically, we say that process $p_i$ \emph{holds a lock on $X_j$ after an execution $\pi$} if
$\textit{or}_j$ $\mathrel{\&} 1=1$, where $\textit{or}_j$ is the value of $r_j$ after $\pi$.


\vspace{1mm}\noindent\textbf{Fast-path transactions.}
For a fast-path transaction $T_k$, the $\Read_k(X_j)$ implementation first reads $r_j$ 
Updating fast-path transactions 
$\Write (X_j,v)$ simply stores the cached state of $X_j$ along with its value $v$ and
if the cache has not been invalidated, updates the shared memory
during $\TryC_k$ by invoking the $\ms{commit-cache}$ primitive.

\vspace{1mm}\noindent\textbf{Direct access inside fast-path transactions.}

\vspace{1mm}\noindent\textbf{Slow-path read-only transactions.}
A read-only transaction simply returns $C_k$ during the tryCommit.

\vspace{1mm}\noindent\textbf{Slow-path updating transactions.}
The $\Write_k(X,v)$ implementation of a slow-path transaction stores
$v$ and the current value of $X_j$ locally, 
deferring the actual update in shared memory to tryCommit. 


\vspace{1mm}\noindent\textbf{Instrumentation cost.}
%

We can now prove the following theorem:
%
\begin{theorem}
\label{th:inswrite}
There exists an opaque HyTM implementation that provides invisible reads, progressiveness
such that
in its every execution $E$, every fast-path transaction $T\in \ms{txns}(E)$
accesses $m=|\Dset(T_k)|$ distinct metadata base objects.
\end{theorem}
%
\begin{proofsketch}

\end{proofsketch}
%
%
\input{prog-fp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Progressive HyTM}
\label{sec:hytm2}
%
We can now prove the following theorem:
%
\begin{theorem}
\label{th:inswrite2}
There exists an opaque HyTM implementation that provides invisible reads
such that (1) in every execution $E$,
every fast-path transaction $T\in \ms{txns}(E)$
accesses one metadata base object,
(2) every execution $E$ is fast-path progressive or for
every fast-path transaction $T\in \ms{txns}(E)$
that returns $A_k$ in $E$, there exists an updating slow-path transaction $T_m \in \ms{txns}(E)$
concurrent to $T_k$.
\end{theorem}
%
\begin{proofsketch}
% 
\end{proofsketch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%