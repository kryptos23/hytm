\section{Hybrid Transactional Memory (HyTM)}
\label{sec:hytm}
%
We now introduce the notion of a \emph{Hybrid Transactional Memory} system. 
A HyTM implementation provides two separate algorithms for each t-operation. 
The first algorithm provided is the \emph{slow-path} implementation, 
and the second algorithm is the \emph{fast-path} implementation. 
% Both slow- and fast-path transactions are governed by the above model, 
% except that fast-path transactions apply a different set of events.

\paragraph{Slow-path events.}
An event of a slow-path transaction is either an invocation or response of a t-operation, or
a \emph{rmw primitive} on a base object. 
A rmw primitive applied to a base object $b$ is specified by a pair of functions $\langle g,h \rangle$~\cite{G05,Her91}. 
Given the state of $b$, $g$ is an \emph{update} function which computes the new state of $b$ and 
$h$ is a \emph{response} function which computes the response returned to the invoking process. 
A rmw primitive is \emph{trivial} if it never affects the state of a base object, 
i.e. if $g$ is the identity, otherwise it is \emph{nontrivial}.
An invocation of a t-operation by transaction $T_k$ is applicable to $C$ 
if $T_k$ has no pending t-operation in $C$. 
A response by $T_k$ is applicable to $C$ if $T_k$ has a matching invocation pending in $C$. 
A \emph{rmw primitive} applied to a base object $b$ is applicable to $C$ 
if the response of the event matches the value of the response function of the primitive applied to the state of $b$ in $C$.
%Applying an event $e$ to a configuration $C$ results in a new configuration $C' = e(C)$. 

\paragraph{Tracking sets and fast-path events.} Processes invoking a fast-path transaction maintain a shared \emph{tracking set} 
$\tau_i$ as part of the process state which one should think of as modeling the \emph{L1 cache} of process $i$. 
$\tau_i$ is a set of triples $(b, v, m)$ where $b$ is a base object identifier, $v$ is a value, 
and $m \in \{shared, exclusive\}$ is a \emph{mode}. 
We assume that there exists some constant $\mathcal{C}$ (representing the size of the L1 cache)
such that the condition $|\tau_i| \leq \mathcal{C}$ must always hold; this condition will be enforced by our model. 
We also assume that $\tau_i$ is initialized to $\emptyset$ whenever 
process $i$ initiates a new transaction. 
A base object $b$ is \emph{present} in $\tau_i$ with mode $m$ if $\exists v, (b,v,m) \in \tau_i$.

An event of a fast-path transaction is either an invocation or response of a t-operation, 
a \emph{cached primitive} on a base object, or a \emph{cache-commit} primitive. 

Like rmw primitives, a cached primitive is also characterized by the pair of update and response functions $\langle g,h \rangle$.
Given a base object $b$ with value $v$ in a configuration $C$, 
a trivial (resp.\ nontrivial) cached primitive $\langle g,h \rangle$ applied to $b$ 
in transaction $T_k$ by process $i$ in $C$ first checks whether $b$ is present in exclusive (resp.\ any) state in $\tau_j$ 
for any $j\neq i$. If so, $\tau_i$ is set to $\emptyset$ and $T_k$ returns $A_k$. 
Otherwise, the triple $(b, v, shared)$ (resp. $(b, g(v), exclusive)$) is added to $\tau_i$. 
Any cached primitive which would cause $|\tau_i|$ to exceed $\mathcal{C}$ instead sets $\tau_i = \emptyset$ 
and returns $A_k$; in this situation, we say $T_k$ has incurred a \emph{capacity abort}. We note that there is some parameter $\mathcal{B}$
inherent to $\mathcal{M}$ such that no transaction whose data set contains 
less than $\mathcal{B}$ t-objects incurs a capacity abort.

The \emph{cache-commit} primitive issued by process $i$ executing transaction $T_k$ from configuration $C$
does the following: for each base object $b$ such that $(b,v,exclusive) \in \tau_i$, the value of $b$ in $C$ is updated to $v$. 
Finally, $\tau_i$ is set to $\emptyset$ and the operation returns $C_k$. 
The \emph{cache-commit} primitive applied by $T_k$ is applicable to $C$ only if $\TryC_k$ is incomplete in $C$.

Fast-path transactions have the following additional property:
consider any configuration $C$ in which process $i$ is executing a fast-path transaction $T_k$ and 
$(b,v,exclusive)\in\tau_i$ (resp.\ $(b,v,shared)\in\tau_i)$. 
If process $j\neq i$ applies an event $e$ immediately after $C$ that performs any primitive 
(resp.\ any \emph{nontrivial} primitive) to $b$, 
then the next event of $T_k$ in any extension of this execution fragment must be the abort event $A_k$. 
We refer to this occurence as a \emph{tracking set abort}. 

We provide two key observations on this model regarding the interactions of non-committed fast path transactions 
with other transactions. 
Let $E$ be any execution of a HyTM implementation $\mathcal{M}$. 
For any fast-path transaction $T_k \in txns(E)$, 
let $E^k$ denote any prefix of $E$ such that $T_k$ is either t-incomplete in $E^k$ or $T_k$ returns $A_k$ in $E^k$. 
Then, the following observations are implied by our model.
%
\begin{observation} 
\label{ob:one}
The execution $E^k$ is indistinguishable to every slow-path transaction $T_m \in \ms{txns}(E^k)$ 
from the execution $\tilde{E}^k$ which is the subsequence of $E^k$ derived by removing all events of $E|k$ from $E^k$. 

If any fast-path transaction $T_m\in \ms{txns}(E^k) \setminus \{T_k\}$ does not incur a tracking set abort in $E^k$, 
then $E^k$ is indistinguishable to $T_m$ from $\tilde{E}^k$. 
\end{observation}
%
Intuitively, these observations say that fast-path transactions which are not yet committed are 
invisible to slow-path transactions, and can communicate with other fast-path transactions only via tracking sets.

\paragraph{Instrumentation.}
%
We now elaborate on how we characterize HyTMs that do not use code instrumentation in fast-path transactions.
Our definition captures the notion that without code instrumentation, fast-path transactions cannot detect
if they are taking steps overlapping with a pending slow-path transaction.
We require the following technical definition: an execution $E$ of a HyTM $\mathcal{M}$ \emph{appears t-sequential}
to a transaction $T_k \in \ms{txns}(E)$ if there exists an execution $E'$ of $\mathcal{M}$
such that the configuration after $E'$ is t-quiescent and $E'\cdot E|k$ is an execution of $\mathcal{M}$
that is indistinguishable to $T_k$ from $E$.
% JK: This definition is now used in the proof (top of case 2 for now, might write it in other places as well). Move back to a definition environment?


Given a HyTM implementation $\mathcal{M}$ operating on a set of t-objects $\mathcal{X}$, 
we partition the set of base objects into a set $\mathbb{D}$ of \emph{data} objects and 
a set $\mathbb{M}$ of \emph{metadata} objects such that $\mathbb{D}$ is a maximal set for which the following properties hold:
%
\begin{itemize}
\item $\mathbb{D} = \bigcup\limits_{X\in\mathcal{X}} \mathbb{D}_X$.
\item For any two t-objects $X\neq Y$, $D_X \cap D_Y = \emptyset$.
\item If there is some execution $E$ of $\mathcal{M}$ for which some transaction $T_k \in txns(E)$ accesses $b$ 
but $X \not\in DSet(T_k)$, then $b\not\in \mathbb{D}_X$. 
\item 
Let $E$ be any execution of $\mathcal{M}$ and 
$e$ be the enabled event of a transaction $T_k \in \ms{txns}(E)$ after $E$ such that $e$ 
applies a primitive to a base object in $\mathbb{D}$ and $e$ does not cause a tracking set abort.
Then, if $E$ appears t-sequential to $T_k$, then $E\cdot e$ also appears t-sequential to $T_k$.
% Let $E=E'\cdot E|k$ be any execution of $\mathcal{M}$ such that $T_k \not\in \ms{txns}(E')$ and
% the configuration after $E'$ is t-quiescent. 
% Let $E\cdot E''$ be any extension of $E$ such that every transaction $T\in \ms{txns}(E')$ it t-incomplete in $E''$.
% Then, in any extension of $E\cdot E''$ in which $T_k$ does not access any base objects in $\mathbb{M}$,
% the configuration after $E'\cdot E''$ is indistinguishable to $T_k$ from a t-quiescent configuration.
%
\end{itemize}
%
Intuitively, base objects in $\mathbb{D}$ hold only the values of t-objects and cannot be used to detect concurrent transactions. 
% We note that any control flow in a HyTM algorithm that utilizes information only 
% from $\mathbb{D}$ is of little use \todo{SR: seems hard to understand}.
%SR: maybe we should elaborate on use of conditional loops?

We now define a HyTM to be \emph{uninstrumented} if transactions cannot access metadata 
(i.e. base objects in $\mathbb{M}$) in any execution. 
%
%
\begin{definition}
\label{def:ins}
A HyTM implementation $\mathcal{M}$ provides \emph{uninstrumented writes (resp.\ reads)} 
if in every execution $E$ of $\mathcal{M}$, for every write-only (resp.\ read-only) transaction $T_k$, 
all primitives in $E|k$ are performed on base objects in $\mathbb{D}$.
\end{definition}
% 
We make the following observation about uninstrumented transactions:
%
\begin{observation}
\label{ob:ins}
Consider any execution $E$ of a HyTM implementation $\mathcal{M}$ which provides uninstrumented reads (resp. writes). 
For any fast-path read-only (resp.\ write-only) transaction $T_k \not\in \ms{txns}(E)$, 
that runs step-contention free after $E$, 
the execution $E$ appears t-quiescent to $T_k$.
\end{observation}
% %
% This observation follows because every execution of an uninstrumented transaction appears t-complete to that transaction.
% %