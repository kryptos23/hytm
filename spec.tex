%!TEX root = htm.tex
\section{Progressive HyTM must perform incremental validation}
\label{sec:lb}
%
%
In this section, we show that it is impossible to implement opaque \emph{progressive} HyTMs with \emph{invisible reads}
with $O$(1) step-complexity read operations for slow-path transactions. 
This result holds even if fast-path transactions may perform
direct trivial accesses.

Formally, we say that a HyTM implementation $\mathcal{M}$ is progressive
for a set $\mathcal{T}$ of transactions
if in any execution $E$ of $\mathcal{M}$; $\mathcal{T} \subseteq \ms{txns}(E)$, 
if any transaction $T_k \in \mathcal{T}$ returns $A_k$ in $E$, there exists 
another concurrent transaction $T_m$ that \emph{conflicts} (both access the same t-object and at least one writes) with $T_k$ in $E$~\cite{tm-book}.

The proof of the lemma below is a simple extension of the analogous lemma from \cite{hytm14disc}
allowing direct trivial accesses inside fast-path transactions which in turn is inspired by an analogous result concerning \emph{disjoint-access parallel} STMs~\cite{AHM09}. 
Intuitively, the proof follows follows from the fact that
the tracking set of a process executing a fast-path transaction is invalidated due to contention on a base
object with another transaction (cf. Remark~\ref{re:traborts}).
%
\begin{lemma}
\label{lm:hytm}
%
Let $\mathcal{M}$ be any progressive HyTM implementation in which fast-path transactions may perform trivial
direct accesses.
Let $E_1 \cdot E_2$ be an execution of $\mathcal{M}$ where
$E_1$ (and resp. $E_2$) is the step contention-free
execution fragment of fast-path transaction $T_1$ (and resp. $T_2$),
$T_1$ and $T_2$ do not conflict in $E_1 \cdot E_2$, and
at least one of $T_1$ or $T_2$ is a fast-path transaction. 
Then, $T_1$ and $T_2$ do not contend on any base object in $E_1 \cdot E_2$.
\end{lemma}
%
We construct an execution of a progressive opaque HyTM in which every t-read performed by a read-only slow-path transaction
must access linear (in the size of the read set) number of distinct base objects.
%
\begin{theorem}
\label{th:impossibility}
Let $\mathcal{M}$ be any progressive opaque HyTM implementation providing invisible reads.
There exists an execution $E$ of $\mathcal{M}$ and some slow-path read-only transaction $T_k \in \ms{txns}(E)$
that incurs a time complexity of $\Omega (m^2)$; $m=|\Rset(T_k)|$.
\end{theorem}
%
\begin{proofsketch}
We construct an execution of a read-only slow-path transaction $T_{\phi}$ that performs $m \in \mathbb{N}$
distinct t-reads of t-objects $X_1,\ldots , X_m$. We show inductively that for each 
$i\in \{1,\ldots , m\}$; $m \in \mathbb{N}$, the $i^{\ms{th}}$ t-read must access $i-1$ distinct base objects
during its execution. The (partial) steps in our execution are depicted in Figure~\ref{fig:indis}.

\end{proofsketch}
%
%
\vspace{1mm}\noindent\textbf{How STM implementations mitigate the lower bound cost.}
NOrec~\cite{norec} is a progressive opaque STM that minimizes the average step-complexity resulting from incremental 
validation of t-reads. Transactions read a global versioned lock at the start, and perform value-based validation
during t-read operations \emph{iff} the global version has changed.
TL2~\cite{DSS06} improves over NOrec by circumventing the lower bound
of Theorem~\ref{th:impossibility}. Concretely, TL2 associates a global version with each t-object updated during
a transaction and performs validation with O(1) complexity during t-reads by simply verifying if the version
of the t-object is greater than the global version read at the start of the transaction. Technically,
NOrec and algorithms in this paper provide a stronger definition of progressiveness: a transaction may abort
only if there is a prefix in which it conflicts with another transaction and both are t-incomplete. TL2 on the other hand allows
a transaction to abort due to a concurrent conflicting transaction.

\vspace{1mm}\noindent\textbf{Implications for disjoint-access parallelism in HyTM.}
The property of disjoint-access parallelism (DAP), in its \emph{weakest} form, ensures that two transactions %$T_1$ and $T_2$
concurrently contend on the same base object 
%(both access the base object and at least one updates it) 
only if their data 
sets are connected in the \emph{conflict graph}, capturing 
data-set overlaps among all concurrent transactions~\cite{AHM09}. It is well known that weak DAP STMs with invisible reads must perform incremental validation even if the required TM-progress condition requires
transactions to commit only in the absence of any concurrent transaction~\cite{tm-book,prog15-pact}. For example, DSTM~\cite{HLM+03} is a weak DAP STM that is progressive and consequently incurs the validation
complexity. On the other hand, TL2 and NOrec are not weak DAP since they employ a global versioned lock that mitigates the cost of incremental validation, but this creates allows two transactions accessing
disjoint data sets to concurrently contend on the same memory location. Indeed, this inspires the proof of Theorem~\ref{th:impossibility}. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[!t]
\begin{center}
	\subfloat[Slow-path transaction $T_{\phi}$ performs $i-1$ distinct t-reads followed by the t-read of $X_i$ that returns value $nv$ 
	writtten by fast-path transaction $T_i$\label{sfig:inv-1}]{\scalebox{0.6}[0.6]{\input{dap}}}
        \\
        \vspace{1mm}
	\subfloat[Fast-path transaction $T_i$ does not contend with any of the $i-1$ t-reads performed by $T_{\phi}$;
	this execution is indistinguishable to $T_{\phi}$ from \ref{sfig:inv-1} and t-read of $X_i$ must return $nv$\label{sfig:inv-2}]{\scalebox{0.6}[0.6]{\input{dap2}}}
	\\
	\vspace{1mm}
	\subfloat[To distinguish the $i-1$ different executions, t-read of $X_i$ by slow-path transaction $T_{\phi}$ is forced
	to access $i-1$ different base objects\label{sfig:inv-3}]{\scalebox{0.6}[0.6]{\input{dap3}}}
	\caption{Proof steps for Theorem~\ref{th:impossibility}
        \label{fig:indis}} 
\end{center}
\end{figure*}
