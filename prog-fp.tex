\begin{algorithm}[!h]
\caption{Opaque HyTM implementation with sequential slow-path and progressive fast-path TM-progress; code for $T_k$ by process $p_i$}
\label{alg:inswrite2}
\begin{algorithmic}[1]
  	\begin{multicols}{2}
  	{
  	\footnotesize
	\Part{Shared objects}{
		\State $v_j \in \mathbb{D}$, for each t-object $X_j$ 
		\Statex ~~~~~allows reads, writes
		\State $r_{j} \in \mathbb{M}$, for each t-object $X_j$
		\State bit $L \in \mathbb{M}$
		\Statex ~~~~~allows reads, writes 
		%\State implemented from reads and writes
		%\State $L$, multi-trylock
	}\EndPart	
	\Statex
	\Part{Process local objects}{
		\State $\Rset(T_k)$ list storing $\{X_j,r_j\}$
		\State $\Wset(T_k)$ bloom filter storing $\{X_j, v_j\}$
	}\EndPart
	\Statex
	
	\textbf{Code for slow-path transactions}
	
	\Part{\Read$_k(X_j)$}\quad\Comment{slow-path}{
		  \If{$X_j\in \Wset(T_k)$}
		    \Return $\Wset(T_k).\lit{locate}(X_j)$ \EndReturn
		  \Else
		  \State $\textit{ov}_j := \Read(v_j)$ 
		  \State $\textit{or}_j := \Read(r_j)$ 
		  \State $\Rset(T_k) := \Rset(T_k)\cup\{X_j,or_j\}$ 
		  \If{$\textit{or}_j$ BITWISE\_AND $0000...0001$}  	
			\Return $A_k$ \EndReturn
		  \EndIf
		  \If{$\exists X_j \in Rset(T_k)$:$(\textit{or}_j\neq \Read(r_j))$}
			\Return $A_k$ \EndReturn
		  \EndIf
		  \EndIf
		  \Return $\textit{ov}_j$ \EndReturn
		
   	 }\EndPart
	\Part{\Write$_k(X_j,v)$}\quad\Comment{slow-path}{
		
			\State $\textit{nv}_j := v$
			\State $\Wset(T_k) := \Wset(T_k)\cup\{X_j,nv_j\}$
			\Return $\ok$ \EndReturn
		
   	}\EndPart
	\Statex
	
	%\Statex	
	\Part{\TryC$_k$()}\quad\Comment{slow-path}{
		\If{$\Wset(T_k)= \emptyset$}
			\Return $C_k$ \EndReturn 
		\EndIf
		\State $L.\lit{cas}(0,1)$
		\State $\lit{acquire}(\Wset(T_k))$
		\If{$\exists X_j \in Rset(T_k)$:$(\textit{or}_j\neq \Read(r_j))$}
			\State $\lit{release}( \ms{Wset}(T_k))$ 
			\Return $A_k$ \EndReturn
		\EndIf
		
		\ForAll{$X_j \in \Wset(T_k)$}
	 		 \State  $v_j.\lit{write}([\textit{nv}_j,k])$
			 
			 
	 	\EndFor		
		\State $\lit{release}(\Wset(T_k))$  
		\State $L.\lit{write}(0)$
   		\Return $C_k$ \EndReturn
   	 }\EndPart		
	
	 
 	\newpage
 	
	

	\textbf{Code for fast-path transactions}	
	
	\Part{$\textit{start}_k()$}{
		\State $l \gets \Read(\ms{L})$ \Comment{cached read} 
		\If{$\ms{l}\neq 0$}
			    \Return $A_k$ \EndReturn
		\EndIf
		
	}\EndPart
	\Statex
	
	\Part{$\textit{read}_k(X_j)$}{\quad\Comment{fast-path}
		
		\State $\textit{ov}_j := v_j.\Read()$ \Comment{cached read} 
		
		\Return $\textit{ov}_j$ \EndReturn
		
   	 }\EndPart
	\Statex
	\Part{$\textit{write}_k(X_j,v)$}{\quad\Comment{fast-path}
	
	\State $\textit{or}_j L= \Read(r_j)$ \Comment{uncached read}
	\State $r_j.\Write({or}_j+2)$ \Comment{uncached write}
	\State $v_j.\Write(v)$ \Comment{cached write}
	\Return $\ok$ \EndReturn
		
   	}\EndPart
	\Statex
	
	%\Statex	
	\Part{$\textit{tryC}_k$()}{\quad\Comment{fast-path}
		%\Return $C_k$ \EndReturn
		\State $\ms{commit-cache}_i$ \Comment{returns $C_k$}
		
   		
   	 }\EndPart		
	
% 	
	}
	\end{multicols}
  \end{algorithmic}
\end{algorithm}
