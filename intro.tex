%!TEX root = htm.tex
\section{Introduction}
\label{sec:intro}
%
\begin{figure*}[!ht]
      
     \scalebox{1}[1]{
     \begin{tabularx}{\textwidth}{c|c|c|c|c}
%	\hline
	~~~~~ & Algorithm~\ref{alg:inswrite} & Algorithm~\ref{alg:inswrite2} & TLE & HybridNorec\\ \hline
	Metadata accesses in read-only h/w & No & yes & Yes & Yes \\ \hline
	Metadata accesses in read-only s/f & No & yes & Yes & Yes \\ \hline
	Metadata accesses in updating h/w & No & yes & Yes & Yes \\ \hline
	h/w-s/f concurrency & No & yes & Yes & Yes \\ \hline
	opacity & No & yes & Yes & Yes \\  \hline
	%    \hline
   \end{tabularx}
\caption{Table}\label{fig:main}    
}
\end{figure*}
%
The \emph{Transactional Memory (TM)} abstraction is a synchronization mechanism 
that allows the programmer to \emph{speculatively} execute sequences of shared-memory
operations as \emph{atomic transactions}.
Most popular TM designs, subsequent to the original proposal in \cite{HM93} 
have implemented all the functionality in software~\cite{norec, ST95,HLM+03, astm, fraser}.
The original dynamic STM implementation \emph{DSTM}~\cite{HLM+03} ensures \emph{progressiveness}: 
a transaction aborts only if there is a read-write \emph{data conflict} with a concurrent
transaction. However, read operations in DSTM must \emph{incrementally} validate
every next read operation. This results in a quadratic  (in the size of the transaction's read
set) step-complexity bound. Subsequent STM 
implementations like \emph{NOrec}~\cite{norec} and \emph{TL2}~\cite{DSS06}
minimize the impact on performance due to incremental validation.
NOrec uses a global sequence lock that is read at the start of a transaction and performs \emph{value-based}
validation during read operations only if the value of the global lock has changed since reading it.
TL2 eliminates incremental validation completely by associating a global sequence lock
value with each data item updated: any read of a data item returns
a value only if the sequence value associated with it is the same as the 
value of the sequence lock read at the start of the transaction. 

In fact, state-of-the-art STM implementations ensure progress in the absence of conflicts with 
$O$(1) complexity read operations while still satisfying \emph{invisible reads}.
Intuitively, this means that read-only transactions do not
apply any nontrivial primitives on the shared memory which is considered importance for performance in
read-dominated workloads.

Nonetheless, TM designs that are implemented entirely in software still incur significant performance overhead.
Thus, current CPUs have included instructions to mark a block of memory accesses as transactional~\cite{Rei12, asf, bluegene}, allowing them to be executed \emph{atomically} in hardware.
Hardware transactions promise even better performance, but they offer no progress guarantees 
since they may experience %\emph{conflict aborts} and
\emph{spurious} aborts. This motivates the need for
\emph{hybrid} TMs in which the \emph{fast} hardware transactions are 
complemented with \emph{slower} software transactions that do not experience spurious aborts.

To allow hardware transactions in a HyTM to detect conflicts with software transactions, 
hardware transactions must be \emph{instrumented} to perform additional metadata accesses, which introduces overhead.
Hardware transactions typically provide automatic contention detection for every memory location accessed within one.
This is at least the case with the Intel Haswell's Transactional Synchronization Extensions~\cite{haswell}.
However, the IBM Power8 ISA allows hardware transactions to access metadata non-speculatively, thus not providing
contention detection for all memory locations accessed. While this has the advantage of potentially reducing aborts
in hardware, this makes the design of HyTM implementations potentially harder to prove correct.

\paragraph{Roadmap.}