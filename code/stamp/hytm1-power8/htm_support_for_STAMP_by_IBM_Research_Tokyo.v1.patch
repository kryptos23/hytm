diff -Naur -x .svn stamp-0.9.10/bayes/bayes.c stamp-0.9.10_Distribute/bayes/bayes.c
--- stamp-0.9.10/bayes/bayes.c	2008-09-09 07:41:49.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/bayes.c	2014-12-18 12:17:57.985567633 +0900
@@ -67,10 +67,14 @@
  *
  * =============================================================================
  */
-
+/* Copyright (c) IBM Corp. 2014. */
 
 #include <assert.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include "data.h"
 #include "learner.h"
 #include "net.h"
@@ -78,6 +82,10 @@
 #include "timer.h"
 #include "tm.h"
 #include "types.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 enum param_types {
     PARAM_EDGE    = (unsigned char)'e',
@@ -237,6 +245,46 @@
      */
 
     parseArgs(argc, (char** const)argv);
+#if defined(__bgq__)
+    if (global_params[PARAM_THREAD] < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -global_params[PARAM_THREAD];
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    global_params[PARAM_THREAD] = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    global_params[PARAM_THREAD] = 2;
+	    break;
+	case 2:
+	    global_params[PARAM_THREAD] = 4;
+	    break;
+	case 3:
+	    global_params[PARAM_THREAD] = 8;
+	    break;
+	case 4:
+	    global_params[PARAM_THREAD] = 16;
+	    break;
+	case 5:
+	    global_params[PARAM_THREAD] = 32;
+	    break;
+	case 6:
+	    global_params[PARAM_THREAD] = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < global_params[PARAM_THREAD]) {
+	    exit(0);
+	}
+    }
+#endif
     long numThread     = global_params[PARAM_THREAD];
     long numVar        = global_params[PARAM_VAR];
     long numRecord     = global_params[PARAM_RECORD];
diff -Naur -x .svn stamp-0.9.10/bayes/Defines.common.mk stamp-0.9.10_Distribute/bayes/Defines.common.mk
--- stamp-0.9.10/bayes/Defines.common.mk	2008-09-09 07:41:49.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/Defines.common.mk	2014-12-18 12:35:51.523567385 +0900
@@ -3,7 +3,9 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
+hostname := $(shell hostname)
 
 PROG := bayes
 
@@ -21,6 +23,7 @@
 	$(LIB)/random.c \
 	$(LIB)/thread.c \
 	$(LIB)/vector.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
@@ -28,6 +31,48 @@
 CFLAGS += -DLEARNER_TRY_REMOVE
 CFLAGS += -DLEARNER_TRY_REVERSE
 
+RUNPARAMS := -v32 -r4096 -n10 -p40 -i2 -e8 -s1
+
+.PHONY:	run1 run2 run4 run6 run8 run12 run16 run32 run64 run128 run-16 run-32 run-64
+
+run1:
+	$(PROGRAM) $(RUNPARAMS) -t1
+
+run2:
+	$(PROGRAM) $(RUNPARAMS) -t2
+
+run4:
+	$(PROGRAM) $(RUNPARAMS) -t4
+
+run6:
+	$(PROGRAM) $(RUNPARAMS) -t6
+
+run8:
+	$(PROGRAM) $(RUNPARAMS) -t8
+
+run12:
+	$(PROGRAM) $(RUNPARAMS) -t12
+
+run16:
+	$(PROGRAM) $(RUNPARAMS) -t16
+
+run32:
+	$(PROGRAM) $(RUNPARAMS) -t32
+
+run64:
+	$(PROGRAM) $(RUNPARAMS) -t64
+
+run128:
+	$(PROGRAM) $(RUNPARAMS) -t128
+
+run-16:
+	$(PROGRAM) $(RUNPARAMS) -t-16
+
+run-32:
+	$(PROGRAM) $(RUNPARAMS) -t-32
+
+run-64:
+	$(PROGRAM) $(RUNPARAMS) -t-64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/bayes/learner.c stamp-0.9.10_Distribute/bayes/learner.c
--- stamp-0.9.10/bayes/learner.c	2008-09-09 07:41:49.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/learner.c	2014-12-18 12:18:09.128880187 +0900
@@ -114,6 +114,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -300,13 +301,22 @@
                  long* startPtr, long* stopPtr)
 {
     long range = max - min;
+#ifdef __GNUC__
     long chunk = MAX(1, ((range + n/2) / n)); /* rounded */
+#else
+    long _tmp = (range + n/2) / n;
+    long chunk = MAX_nogcc(1, _tmp); /* rounded */
+#endif
     long start = min + chunk * id;
     long stop;
     if (id == (n-1)) {
         stop = max;
     } else {
+#ifdef __GNUC__
         stop = MIN(max, (start + chunk));
+#else
+        stop = MIN_nogcc(max, (start + chunk));
+#endif
     }
 
     *startPtr = start;
@@ -383,7 +393,7 @@
 
     } /* foreach variable */
 
-    TM_BEGIN();
+    TM_BEGIN_ID(0);
     float globalBaseLogLikelihood =
         TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
     TM_SHARED_WRITE_F(learnerPtr->baseLogLikelihood,
@@ -478,7 +488,7 @@
             taskPtr->fromId = bestLocalIndex;
             taskPtr->toId = v;
             taskPtr->score = score;
-            TM_BEGIN();
+            TM_BEGIN_ID(1);
             status = TMLIST_INSERT(taskListPtr, (void*)taskPtr);
             TM_END();
             assert(status);
@@ -1186,7 +1196,7 @@
     while (1) {
 
         learner_task_t* taskPtr;
-        TM_BEGIN();
+        TM_BEGIN_ID(2);
         taskPtr = TMpopTask(TM_ARG  taskListPtr);
         TM_END();
         if (taskPtr == NULL) {
@@ -1199,7 +1209,7 @@
 
         bool_t isTaskValid;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(3);
 
         /*
          * Check if task is still valid
@@ -1264,7 +1274,7 @@
             switch (op) {
                 float newBaseLogLikelihood;
                 case OPERATION_INSERT: {
-                    TM_BEGIN();
+                    TM_BEGIN_ID(4);
                     TMpopulateQueryVectors(TM_ARG
                                            netPtr,
                                            toId,
@@ -1285,7 +1295,7 @@
                     TM_SHARED_WRITE_F(localBaseLogLikelihoods[toId],
                                       newBaseLogLikelihood);
                     TM_END();
-                    TM_BEGIN();
+                    TM_BEGIN_ID(5);
                     long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
                     TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent + 1));
                     TM_END();
@@ -1293,7 +1303,7 @@
                 }
 #ifdef LEARNER_TRY_REMOVE
                 case OPERATION_REMOVE: {
-                    TM_BEGIN();
+                    TM_BEGIN_ID(6);
                     TMpopulateQueryVectors(TM_ARG
                                            netPtr,
                                            fromId,
@@ -1314,7 +1324,7 @@
                     TM_SHARED_WRITE_F(localBaseLogLikelihoods[fromId],
                                       newBaseLogLikelihood);
                     TM_END();
-                    TM_BEGIN();
+                    TM_BEGIN_ID(7);
                     long numTotalParent = (long)TM_SHARED_READ(learnerPtr->numTotalParent);
                     TM_SHARED_WRITE(learnerPtr->numTotalParent, (numTotalParent - 1));
                     TM_END();
@@ -1323,7 +1333,7 @@
 #endif /* LEARNER_TRY_REMOVE */
 #ifdef LEARNER_TRY_REVERSE
                 case OPERATION_REVERSE: {
-                    TM_BEGIN();
+                    TM_BEGIN_ID(8);
                     TMpopulateQueryVectors(TM_ARG
                                            netPtr,
                                            fromId,
@@ -1345,7 +1355,7 @@
                                       newBaseLogLikelihood);
                     TM_END();
 
-                    TM_BEGIN();
+                    TM_BEGIN_ID(9);
                     TMpopulateQueryVectors(TM_ARG
                                            netPtr,
                                            toId,
@@ -1382,7 +1392,7 @@
         float baseLogLikelihood;
         long numTotalParent;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(10);
         float oldBaseLogLikelihood =
             (float)TM_SHARED_READ_F(learnerPtr->baseLogLikelihood);
         float newBaseLogLikelihood = oldBaseLogLikelihood + deltaLogLikelihood;
@@ -1411,7 +1421,7 @@
         arg.basePenalty       = basePenalty;
         arg.baseLogLikelihood = baseLogLikelihood;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(11);
         newTask = TMfindBestInsertTask(TM_ARG  &arg);
         TM_END();
 
@@ -1422,7 +1432,7 @@
         }
 
 #ifdef LEARNER_TRY_REMOVE
-        TM_BEGIN();
+        TM_BEGIN_ID(12);
         newTask = TMfindBestRemoveTask(TM_ARG  &arg);
         TM_END();
 
@@ -1434,7 +1444,7 @@
 #endif /* LEARNER_TRY_REMOVE */
 
 #ifdef LEARNER_TRY_REVERSE
-        TM_BEGIN();
+        TM_BEGIN_ID(13);
         newTask = TMfindBestReverseTask(TM_ARG  &arg);
         TM_END();
 
@@ -1448,7 +1458,7 @@
         if (bestTask.toId != -1) {
             learner_task_t* tasks = learnerPtr->tasks;
             tasks[toId] = bestTask;
-            TM_BEGIN();
+            TM_BEGIN_ID(14);
             TMLIST_INSERT(taskListPtr, (void*)&tasks[toId]);
             TM_END();
 #ifdef TEST_LEARNER
diff -Naur -x .svn stamp-0.9.10/bayes/learner.h stamp-0.9.10_Distribute/bayes/learner.h
--- stamp-0.9.10/bayes/learner.h	2008-09-09 07:41:49.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/learner.h	2014-12-18 12:18:18.303758325 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef LEARNER_H
@@ -80,7 +81,17 @@
 
 typedef struct learner_task learner_task_t;
 
+#if defined( __370__)
+#define CACHE_LINE_SIZE (256)
+#elif defined(__bgq__)
+#define CACHE_LINE_SIZE (128)
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define CACHE_LINE_SIZE (128)
+#elif defined(__x86_64__)
 #define CACHE_LINE_SIZE (64)
+#else
+#define CACHE_LINE_SIZE (64)
+#endif
 
 typedef struct learner {
     adtree_t* adtreePtr;
diff -Naur -x .svn stamp-0.9.10/bayes/Makefile.hle_intel stamp-0.9.10_Distribute/bayes/Makefile.hle_intel
--- stamp-0.9.10/bayes/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/Makefile.hle_intel	2014-12-18 12:25:58.863661327 +0900
@@ -0,0 +1,17 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+# ==============================================================================
+#
+# End of Makefile.hle_intel
+#
+# ==============================================================================
diff -Naur -x .svn stamp-0.9.10/bayes/Makefile.htm_ibm stamp-0.9.10_Distribute/bayes/Makefile.htm_ibm
--- stamp-0.9.10/bayes/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/Makefile.htm_ibm	2014-12-18 12:26:05.517598840 +0900
@@ -0,0 +1,17 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+# ==============================================================================
+#
+# End of Makefile.htm_ibm
+#
+# ==============================================================================
diff -Naur -x .svn stamp-0.9.10/bayes/Makefile.lock stamp-0.9.10_Distribute/bayes/Makefile.lock
--- stamp-0.9.10/bayes/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/bayes/Makefile.lock	2014-12-18 12:35:55.629652317 +0900
@@ -0,0 +1,43 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+
+.PHONY: test_data
+test_data: CFLAGS += -DTEST_DATA -O0
+test_data: LIB_SRCS := $(LIB)/{bitmap,list,queue,random,mt19937ar,vector}.c
+test_data:
+	$(CC) $(CFLAGS) data.c sort.c net.c $(LIB_SRCS) -o $@
+
+.PHONY: test_net
+test_net: CFLAGS += -DTEST_NET -O0
+test_net: LIB_SRCS := $(LIB)/{list,queue,bitmap,random,mt19937ar,vector}.c
+test_net:
+	$(CC) $(CFLAGS) net.c $(LIB_SRCS) -o $@
+
+.PHONY: test_adtree
+test_adtree: CFLAGS += -DTEST_ADTREE -O0
+test_adtree: LIB_SRCS := $(LIB)/{bitmap,queue,list,random,mt19937ar,vector}.c
+test_adtree:
+	$(CC) $(CFLAGS) adtree.c data.c net.c sort.c $(LIB_SRCS) -o $@
+
+.PHONY: test_learner
+test_learner: CFLAGS += -DTEST_LEARNER -O0
+test_learner: LIB_SRCS := $(LIB)/{bitmap,list,queue,random,mt19937ar,thread,vector}.c -lm
+test_learner:
+	$(CC) $(CFLAGS) learner.c sort.c adtree.c data.c net.c $(LIB_SRCS) -o $@
+	
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/common/Defines.common.mk stamp-0.9.10_Distribute/common/Defines.common.mk
--- stamp-0.9.10/common/Defines.common.mk	2008-09-09 07:42:37.000000000 +0900
+++ stamp-0.9.10_Distribute/common/Defines.common.mk	2014-12-18 15:33:30.689601157 +0900
@@ -3,16 +3,56 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
+enable_IBM_optimizations := yes
 
+platform := $(shell uname)
+architecture := $(shell uname -m)
+hostname := $(shell hostname)
+ifeq ($(platform),OS/390)
+CC       := c89
+CFLAGS   += '-Wc,HALTON(3296),LANGLVL(extc99),FLOAT(ieee),XPLINK,ARCH(10),TUNE(10),LP64'
+CFLAGS   += -D_XOPEN_SOURCE=600 -D_UNIX03_SOURCE
+CFLAGS   += -O3
+CFLAGS   += -I$(LIB)
+CPP      := c++
+CPPFLAGS += $(CFLAGS)
+LD       := c89
+LDFLAGS  += -Wl,XPLINK,LP64
+LIBS     += 
+else
+ifeq ($(platform),AIX)
+CC       := /usr/vac/bin/xlc_r
+CFLAGS   += -O3 -q64 -g -qstrict
+CFLAGS   += -I$(LIB)
+CPP      := /usr/vac/bin/xlC_r
+CPPFLAGS += $(CFLAGS)
+LD       := /usr/vac/bin/xlc_r
+LDFLAGS  += $(CFLAGS)
+LIBS     += -lm
+else
 CC       := gcc
+ifeq ($(architecture),x86_64)
+CFLAGS   += -g -Wall -pthread  # We no longer use gcc's built-in functions for TSX.
+#CFLAGS   += -g -Wall -pthread -mrtm  # For hle_intel, enable this.
+else
+ifeq ($(architecture),ppc64)
+# We need 64-bit binaries, because bayes allocates > 3GB memory.
+CFLAGS   += -g -Wall -pthread -mpowerpc64 -mcpu=power6 -m64
+else
 CFLAGS   += -g -Wall -pthread
+endif
+endif
 CFLAGS   += -O3
 CFLAGS   += -I$(LIB)
 CPP      := g++
 CPPFLAGS += $(CFLAGS)
 LD       := g++
 LIBS     += -lpthread
+LDFLAGS  += $(CFLAGS)
+endif
+endif
 
 # Remove these files when doing clean
 OUTPUT +=
diff -Naur -x .svn stamp-0.9.10/common/Makefile.hle_intel stamp-0.9.10_Distribute/common/Makefile.hle_intel
--- stamp-0.9.10/common/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/common/Makefile.hle_intel	2014-12-18 12:36:31.294599240 +0900
@@ -0,0 +1,43 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+CFLAGS += -DHLE_INTEL
+# CFLAGS += -mrtm		# x86_64 GCC
+# CFLAGS += -mhtm		# PPC GCC
+#LDFLAGS += -static
+
+SRCS += $(LIB)/hle_intel.c
+
+OBJS := ${SRCS:.c=.o}
+
+# ==============================================================================
+# Rules
+# ==============================================================================
+
+.PHONY: default
+default: $(PROG).hle_intel
+
+.PHONY: clean cleanobj
+clean:
+	$(RM) $(OBJS) $(PROG).hle_intel $(OUTPUT)
+
+cleanobj:
+	$(RM) $(OBJS) $(OUTPUT)
+
+$(PROG).hle_intel: $(OBJS)
+	$(LD) $(LDFLAGS) $^ $(LIBS) -o $(PROG).hle_intel
+
+include ../common/Makefile.common
+
+PROGRAM := ./$(PROG).hle_intel
+
+# ==============================================================================
+#
+# Makefile.seq
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/common/Makefile.htm_ibm stamp-0.9.10_Distribute/common/Makefile.htm_ibm
--- stamp-0.9.10/common/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/common/Makefile.htm_ibm	2014-12-18 12:36:37.110661621 +0900
@@ -0,0 +1,46 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+hostname := $(shell hostname)
+
+CFLAGS += -DHTM_IBM # -DUSE_MUTEX
+# CFLAGS += -mrtm		# x86_64 GCC
+# CFLAGS += -mhtm		# PPC GCC
+#LDFLAGS += -static
+
+SRCS += $(LIB)/htm_ibm.c \
+     $(LIB)/htm_util.c
+
+OBJS := ${SRCS:.c=.o}
+
+# ==============================================================================
+# Rules
+# ==============================================================================
+
+.PHONY: default
+default: $(PROG).htm_ibm
+
+.PHONY: clean cleanobj
+clean:
+	$(RM) $(OBJS) $(PROG).htm_ibm $(OUTPUT)
+
+cleanobj:
+	$(RM) $(OBJS) $(OUTPUT)
+
+$(PROG).htm_ibm: $(OBJS)
+	$(LD) $(LDFLAGS) $^ $(LIBS) -o $(PROG).htm_ibm
+
+include ../common/Makefile.common
+
+PROGRAM := ./$(PROG).htm_ibm
+
+# ==============================================================================
+#
+# Makefile.seq
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/common/Makefile.lock stamp-0.9.10_Distribute/common/Makefile.lock
--- stamp-0.9.10/common/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/common/Makefile.lock	2014-12-18 12:36:43.270568344 +0900
@@ -0,0 +1,36 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+CFLAGS += -DGLOBAL_LOCK
+
+# ==============================================================================
+# Rules
+# ==============================================================================
+
+.PHONY: default
+default: $(PROG).lock
+
+.PHONY: clean cleanobj
+clean:
+	$(RM) $(OBJS) $(PROG).lock $(OUTPUT)
+
+cleanobj:
+	$(RM) $(OBJS) $(OUTPUT)
+
+$(PROG).lock: $(OBJS)
+	$(LD) $(LDFLAGS) $^ $(LIBS) -o $(PROG).lock
+
+include ../common/Makefile.common
+
+PROGRAM := ./$(PROG).lock
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/common/Makefile.seq stamp-0.9.10_Distribute/common/Makefile.seq
--- stamp-0.9.10/common/Makefile.seq	2008-09-09 07:42:37.000000000 +0900
+++ stamp-0.9.10_Distribute/common/Makefile.seq	2014-12-18 12:36:48.697598732 +0900
@@ -3,24 +3,30 @@
 # Makefile.seq
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
+#CFLAGS += -DGLOBAL_LOCK
 
 # ==============================================================================
 # Rules
 # ==============================================================================
 
 .PHONY: default
-default: $(PROG)
+default: $(PROG).seq
 
-.PHONY: clean
+.PHONY: clean cleanobj
 clean:
-	$(RM) $(OBJS) $(PROG) $(OUTPUT)
+	$(RM) $(OBJS) $(PROG).seq $(OUTPUT)
 
-$(PROG): $(OBJS)
-	$(LD) $(LDFLAGS) $^ $(LIBS) -o $(PROG)
+cleanobj:
+	$(RM) $(OBJS) $(OUTPUT)
+
+$(PROG).seq: $(OBJS)
+	$(LD) $(LDFLAGS) $^ $(LIBS) -o $(PROG).seq
 
 include ../common/Makefile.common
 
+PROGRAM := ./$(PROG).seq
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/genome/Defines.common.mk stamp-0.9.10_Distribute/genome/Defines.common.mk
--- stamp-0.9.10/genome/Defines.common.mk	2008-09-09 07:41:50.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/Defines.common.mk	2014-12-18 15:38:13.954790275 +0900
@@ -3,10 +3,29 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+platform := $(shell uname)
+architecture := $(shell uname -m)
+hostname := $(shell hostname)
+
+CFLAGS += -DUSE_TLH
 CFLAGS += -DLIST_NO_DUPLICATES
-CFLAGS += -DCHUNK_STEP1=12
+
+ifeq ($(enable_IBM_optimizations),yes)
+ifeq ($(platform),AIX)
+CFLAGS += -DCHUNK_STEP1=2  # For P8
+else
+ifeq ($(architecture),ppc64)
+CFLAGS += -DCHUNK_STEP1=2  # For P8
+else
+CFLAGS += -DCHUNK_STEP1=2  # Optimized default
+endif
+endif
+else
+CFLAGS += -DCHUNK_STEP1=12  # Default for original STAMP
+endif
 
 PROG := genome
 
@@ -25,9 +44,53 @@
 	$(LIB)/mt19937ar.c \
 	$(LIB)/thread.c \
 	$(LIB)/vector.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+#RUNPARAMS := -g256 -s16 -n16384
+RUNPARAMS := -g16384 -s64 -n16777216
+
+.PHONY:	run1 run2 run4 run6 run8 run12 run16 run32 run64 run128 run-16 run-32 run-64
+
+run1:
+	$(PROGRAM) $(RUNPARAMS) -t1
+
+run2:
+	$(PROGRAM) $(RUNPARAMS) -t2
+
+run4:
+	$(PROGRAM) $(RUNPARAMS) -t4
+
+run6:
+	$(PROGRAM) $(RUNPARAMS) -t6
+
+run8:
+	$(PROGRAM) $(RUNPARAMS) -t8
+
+run12:
+	$(PROGRAM) $(RUNPARAMS) -t12
+
+run16:
+	$(PROGRAM) $(RUNPARAMS) -t16
+
+run32:
+	$(PROGRAM) $(RUNPARAMS) -t32
+
+run64:
+	$(PROGRAM) $(RUNPARAMS) -t64
+
+run128:
+	$(PROGRAM) $(RUNPARAMS) -t128
+
+run-16:
+	$(PROGRAM) $(RUNPARAMS) -t-16
+
+run-32:
+	$(PROGRAM) $(RUNPARAMS) -t-32
+
+run-64:
+	$(PROGRAM) $(RUNPARAMS) -t-64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/genome/genome.c stamp-0.9.10_Distribute/genome/genome.c
--- stamp-0.9.10/genome/genome.c	2008-09-09 07:41:50.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/genome.c	2014-12-18 12:18:37.117595423 +0900
@@ -67,10 +67,15 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -82,6 +87,10 @@
 #include "timer.h"
 #include "tm.h"
 #include "vector.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 
 enum param_types {
@@ -188,6 +197,46 @@
 
     /* Initialization */
     parseArgs(argc, (char** const)argv);
+#if defined(__bgq__)
+    if (global_params[PARAM_THREAD] < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -global_params[PARAM_THREAD];
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    global_params[PARAM_THREAD] = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    global_params[PARAM_THREAD] = 2;
+	    break;
+	case 2:
+	    global_params[PARAM_THREAD] = 4;
+	    break;
+	case 3:
+	    global_params[PARAM_THREAD] = 8;
+	    break;
+	case 4:
+	    global_params[PARAM_THREAD] = 16;
+	    break;
+	case 5:
+	    global_params[PARAM_THREAD] = 32;
+	    break;
+	case 6:
+	    global_params[PARAM_THREAD] = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < global_params[PARAM_THREAD]) {
+	    exit(0);
+	}
+    }
+#endif
     SIM_GET_NUM_CPU(global_params[PARAM_THREAD]);
 
     printf("Creating gene and segments... ");
diff -Naur -x .svn stamp-0.9.10/genome/Makefile.hle_intel stamp-0.9.10_Distribute/genome/Makefile.hle_intel
--- stamp-0.9.10/genome/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/Makefile.hle_intel	2014-12-18 12:37:08.658630038 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/genome/Makefile.htm_ibm stamp-0.9.10_Distribute/genome/Makefile.htm_ibm
--- stamp-0.9.10/genome/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/Makefile.htm_ibm	2014-12-18 12:37:16.428945330 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/genome/Makefile.lock stamp-0.9.10_Distribute/genome/Makefile.lock
--- stamp-0.9.10/genome/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/Makefile.lock	2014-12-18 12:37:22.633598949 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/genome/nucleotide.h stamp-0.9.10_Distribute/genome/nucleotide.h
--- stamp-0.9.10/genome/nucleotide.h	2008-09-09 07:41:50.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/nucleotide.h	2014-12-18 12:18:47.093630686 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef NUCLEOTIDE_H
@@ -74,10 +75,18 @@
 
 
 typedef enum nucleotide_type {
+#ifdef __370__
+    /* Use ASCII for compatibility */
+    NUCLEOTIDE_ADENINE  = '\x61',
+    NUCLEOTIDE_CYTOSINE = '\x63',
+    NUCLEOTIDE_GUANINE  = '\x67',
+    NUCLEOTIDE_THYMINE  = '\x74',
+#else
     NUCLEOTIDE_ADENINE  = 'a',
     NUCLEOTIDE_CYTOSINE = 'c',
     NUCLEOTIDE_GUANINE  = 'g',
     NUCLEOTIDE_THYMINE  = 't',
+#endif
     NUCLEOTIDE_NUM_TYPE = 4
 } nucleotide_type_t;
 
diff -Naur -x .svn stamp-0.9.10/genome/segments.c stamp-0.9.10_Distribute/genome/segments.c
--- stamp-0.9.10/genome/segments.c	2008-09-09 07:41:51.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/segments.c	2014-12-18 12:19:06.248630798 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -184,7 +185,11 @@
     /* Add extra segments to fill holes and ensure overlap */
     maxZeroRunLength = segmentLength - 1;
     for (i = 0; i < numStart; i++) {
+#ifdef __GNUC__
         long i_stop = MIN((i+maxZeroRunLength), numStart);
+#else
+        long i_stop = MIN_nogcc((i+maxZeroRunLength), numStart);
+#endif
         for ( /* continue */; i < i_stop; i++) {
             if (bitmap_isSet(startBitmapPtr, i)) {
                 break;
diff -Naur -x .svn stamp-0.9.10/genome/segments.h stamp-0.9.10_Distribute/genome/segments.h
--- stamp-0.9.10/genome/segments.h	2008-09-09 07:41:51.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/segments.h	2014-12-18 12:19:10.490661083 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef SEGMENTS_H
diff -Naur -x .svn stamp-0.9.10/genome/sequencer.c stamp-0.9.10_Distribute/genome/sequencer.c
--- stamp-0.9.10/genome/sequencer.c	2008-09-09 07:41:51.000000000 +0900
+++ stamp-0.9.10_Distribute/genome/sequencer.c	2014-12-17 16:11:03.488692872 +0900
@@ -139,7 +139,19 @@
 static ulong_t
 hashSegment (const void* keyPtr)
 {
+#if 0
+  char *str = (char *)keyPtr;
+  ulong_t hash = 0;
+    ulong_t c;
+
+    while ((c = *str++) != '\0') {
+        hash = c + (hash << 6) + (hash << 16) - hash;
+    }
+
+    return hash;
+#else
     return (ulong_t)hash_sdbm((char*)keyPtr); /* can be any "good" hash function */
+#endif
 }
 
 
@@ -151,7 +163,27 @@
 static long
 compareSegment (const pair_t* a, const pair_t* b)
 {
+#if 0
+  char *a_str = (char *)(a->firstPtr);
+  char *b_str = (char *)(b->firstPtr);
+  for ( ; ; ) {
+    char a_char = *a_str++;
+    char b_char = *b_str++;
+    char diff;
+    if (a_char == '\0') {
+      if (b_char == '\0')
+	return 0;
+      return -1;
+    } else if (b_char == '\0') {
+      return 1;
+    }
+    diff = a_char - b_char;
+    if (diff != 0)
+      return (long)(signed char)diff;
+  }
+#else
     return strcmp((char*)(a->firstPtr), (char*)(b->firstPtr));
+#endif
 }
 
 
@@ -270,7 +302,7 @@
     /*
      * Step 1: Remove duplicate segments
      */
-#if defined(HTM) || defined(STM)
+#if defined(HTM) || defined(STM) || defined(HTM_IBM) || defined(HLE_INTEL) || defined(GLOBAL_LOCK)
     long numThread = thread_getNumThread();
     {
         /* Choose disjoint segments [i_start,i_stop) for each thread */
@@ -287,10 +319,14 @@
     i_stop = numSegment;
 #endif /* !(HTM || STM) */
     for (i = i_start; i < i_stop; i+=CHUNK_STEP1) {
-        TM_BEGIN();
+        TM_BEGIN_ID(0);
         {
             long ii;
+#ifdef __GNUC__
             long ii_stop = MIN(i_stop, (i+CHUNK_STEP1));
+#else
+            long ii_stop = MIN_nogcc(i_stop, (i+CHUNK_STEP1));
+#endif
             for (ii = i; ii < ii_stop; ii++) {
                 void* segment = vector_at(segmentsContentsPtr, ii);
                 TMHASHTABLE_INSERT(uniqueSegmentsPtr,
@@ -327,7 +363,7 @@
     numUniqueSegment = hashtable_getSize(uniqueSegmentsPtr);
     entryIndex = 0;
 
-#if defined(HTM) || defined(STM)
+#if defined(HTM) || defined(STM) || defined(HTM_IBM) || defined(HLE_INTEL) || defined(GLOBAL_LOCK)
     {
         /* Choose disjoint segments [i_start,i_stop) for each thread */
         long num = uniqueSegmentsPtr->numBucket;
@@ -366,7 +402,7 @@
             bool_t status;
 
             /* Find an empty constructEntries entry */
-            TM_BEGIN();
+            TM_BEGIN_ID(1);
             while (((void*)TM_SHARED_READ_P(constructEntries[entryIndex].segment)) != NULL) {
                 entryIndex = (entryIndex + 1) % numUniqueSegment; /* look for empty */
             }
@@ -392,7 +428,7 @@
             for (j = 1; j < segmentLength; j++) {
                 startHash = (ulong_t)segment[j-1] +
                             (startHash << 6) + (startHash << 16) - startHash;
-                TM_BEGIN();
+                TM_BEGIN_ID(2);
                 status = TMTABLE_INSERT(startHashToConstructEntryTables[j],
                                         (ulong_t)startHash,
                                         (void*)constructEntryPtr );
@@ -405,7 +441,7 @@
              */
             startHash = (ulong_t)segment[j-1] +
                         (startHash << 6) + (startHash << 16) - startHash;
-            TM_BEGIN();
+            TM_BEGIN_ID(3);
             status = TMTABLE_INSERT(hashToConstructEntryTable,
                                     (ulong_t)startHash,
                                     (void*)constructEntryPtr);
@@ -429,7 +465,7 @@
         long index_start;
         long index_stop;
 
-#if defined(HTM) || defined(STM)
+#if defined(HTM) || defined(STM) || defined(HTM_IBM) || defined(HLE_INTEL) || defined(GLOBAL_LOCK)
         {
             /* Choose disjoint segments [index_start,index_stop) for each thread */
             long partitionSize = (numUniqueSegment + numThread/2) / numThread; /* with rounding */
@@ -473,7 +509,7 @@
                 long newLength = 0;
 
                 /* endConstructEntryPtr is local except for properties startPtr/endPtr/length */
-                TM_BEGIN();
+                TM_BEGIN_ID(4);
 
                 /* Check if matches */
                 if (TM_SHARED_READ(startConstructEntryPtr->isStart) &&
@@ -551,7 +587,11 @@
                         constructEntry_t* constructEntryPtr = &constructEntries[i];
                         char* segment = constructEntryPtr->segment;
                         constructEntryPtr->endHash = (ulong_t)hashString(&segment[index]);
+#ifdef __GNUC__
                         endInfoEntries[j].jumpToNext = MAX(1, (i - j));
+#else
+                        endInfoEntries[j].jumpToNext = MAX_nogcc(1, (i - j));
+#endif
                         j = i;
                     }
                 }
diff -Naur -x .svn stamp-0.9.10/intruder/decoder.c stamp-0.9.10_Distribute/intruder/decoder.c
--- stamp-0.9.10/intruder/decoder.c	2008-09-09 07:41:52.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/decoder.c	2014-12-18 12:19:24.970661388 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 #include <assert.h>
 #include <stdlib.h>
@@ -79,6 +80,9 @@
 #include "queue.h"
 #include "tm.h"
 #include "types.h"
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+#include "rbtree.h"
+#endif
 
 
 struct decoder {
@@ -103,7 +107,10 @@
 
     decoderPtr = (decoder_t*)malloc(sizeof(decoder_t));
     if (decoderPtr) {
-        decoderPtr->fragmentedMapPtr = MAP_ALLOC(NULL, NULL);
+	/* Modified by Odaira begin */
+        decoderPtr->fragmentedMapPtr = TMMAP_ALLOC(NULL, NULL);
+        /*decoderPtr->fragmentedMapPtr = MAP_ALLOC(NULL, NULL);*/
+	/* Modified by Odaira end */
         assert(decoderPtr->fragmentedMapPtr);
         decoderPtr->decodedQueuePtr = queue_alloc(1024);
         assert(decoderPtr->decodedQueuePtr);
@@ -121,7 +128,10 @@
 decoder_free (decoder_t* decoderPtr)
 {
     queue_free(decoderPtr->decodedQueuePtr);
-    MAP_FREE(decoderPtr->fragmentedMapPtr);
+    /* Modified by Odaira begin */
+    TMMAP_FREE(decoderPtr->fragmentedMapPtr);
+    /*MAP_FREE(decoderPtr->fragmentedMapPtr);*/
+    /* Modified by Odaira end */
     free(decoderPtr);
 }
 
@@ -341,14 +351,25 @@
     if (numFragment > 1) {
 
         MAP_T* fragmentedMapPtr = decoderPtr->fragmentedMapPtr;
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+	rbtree_t *fragmentListPtr =
+	    (rbtree_t*)TMMAP_FIND(fragmentedMapPtr, (void*)flowId);
+#else
         list_t* fragmentListPtr =
             (list_t*)TMMAP_FIND(fragmentedMapPtr, (void*)flowId);
+#endif
 
         if (fragmentListPtr == NULL) {
 
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+	    fragmentListPtr = TMRBTREE_ALLOC(&packet_compareFragmentId);
+	    assert(fragmentListPtr);
+	    status = TMRBTREE_INSERT(fragmentListPtr, (void*)packetPtr, (void*)packetPtr);
+#else
             fragmentListPtr = TMLIST_ALLOC(&packet_compareFragmentId);
             assert(fragmentListPtr);
             status = TMLIST_INSERT(fragmentListPtr, (void*)packetPtr);
+#endif
             assert(status);
             status = TMMAP_INSERT(fragmentedMapPtr,
                                   (void*)flowId,
@@ -357,11 +378,16 @@
 
         } else {
 
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+	    packet_t* firstFragmentPtr =
+		(packet_t*)TMRBTREE_GET_ROOT_KEY(fragmentListPtr);
+#else
             list_iter_t it;
             TMLIST_ITER_RESET(&it, fragmentListPtr);
             assert(TMLIST_ITER_HASNEXT(&it, fragmentListPtr));
             packet_t* firstFragmentPtr =
                 (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+#endif
             long expectedNumFragment = firstFragmentPtr->numFragment;
 
             if (numFragment != expectedNumFragment) {
@@ -370,21 +396,47 @@
                 return ERROR_NUMFRAGMENT;
             }
 
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+	    status = TMRBTREE_INSERT(fragmentListPtr, (void*)packetPtr, (void*)packetPtr);
+#else
             status = TMLIST_INSERT(fragmentListPtr, (void*)packetPtr);
+#endif
             assert(status);
 
             /*
              * If we have all the fragments we can reassemble them
              */
 
-            if (TMLIST_GETSIZE(fragmentListPtr) == numFragment) {
+            if (
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+		TMRBTREE_GET_SIZE(fragmentListPtr) == numFragment
+#else
+		TMLIST_GETSIZE(fragmentListPtr) == numFragment
+#endif
+		) {
 
                 long numByte = 0;
                 long i = 0;
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+		rbtree_iter_t it;
+		TMRBTREE_ITER_RESET(&it, fragmentListPtr);
+#else
                 TMLIST_ITER_RESET(&it, fragmentListPtr);
-                while (TMLIST_ITER_HASNEXT(&it, fragmentListPtr)) {
+#endif
+                while (
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+		       TMRBTREE_ITER_HASNEXT(&it, fragmentListPtr)
+#else
+		       TMLIST_ITER_HASNEXT(&it, fragmentListPtr)
+#endif
+		       ) {
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+                    packet_t* fragmentPtr =
+                        (packet_t*)TMRBTREE_ITER_NEXT(&it, fragmentListPtr);
+#else
                     packet_t* fragmentPtr =
                         (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+#endif
                     assert(fragmentPtr->flowId == flowId);
                     if (fragmentPtr->fragmentId != i) {
                         status = TMMAP_REMOVE(fragmentedMapPtr, (void*)flowId);
@@ -399,10 +451,25 @@
                 assert(data);
                 data[numByte] = '\0';
                 char* dst = data;
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+                TMRBTREE_ITER_RESET(&it, fragmentListPtr);
+#else
                 TMLIST_ITER_RESET(&it, fragmentListPtr);
-                while (TMLIST_ITER_HASNEXT(&it, fragmentListPtr)) {
+#endif
+                while (
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+		       TMRBTREE_ITER_HASNEXT(&it, fragmentListPtr)
+#else
+		       TMLIST_ITER_HASNEXT(&it, fragmentListPtr)
+#endif
+		       ) {
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+                    packet_t* fragmentPtr =
+                        (packet_t*)TMRBTREE_ITER_NEXT(&it, fragmentListPtr);
+#else
                     packet_t* fragmentPtr =
                         (packet_t*)TMLIST_ITER_NEXT(&it, fragmentListPtr);
+#endif
                     memcpy(dst, fragmentPtr->data, fragmentPtr->length);
                     dst += fragmentPtr->length;
                 }
@@ -417,7 +484,11 @@
                 status = TMQUEUE_PUSH(decodedQueuePtr, (void*)decodedPtr);
                 assert(status);
 
+#ifdef USE_RBTREE_FOR_FRAGMENT_REASSEMBLE
+                TMRBTREE_FREE(fragmentListPtr);
+#else
                 TMLIST_FREE(fragmentListPtr);
+#endif
                 status = TMMAP_REMOVE(fragmentedMapPtr, (void*)flowId);
                 assert(status);
             }
diff -Naur -x .svn stamp-0.9.10/intruder/Defines.common.mk stamp-0.9.10_Distribute/intruder/Defines.common.mk
--- stamp-0.9.10/intruder/Defines.common.mk	2008-09-09 07:41:52.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/Defines.common.mk	2014-12-18 15:40:06.573611047 +0900
@@ -3,8 +3,11 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+hostname := $(shell hostname)
+
 PROG := intruder
 
 SRCS += \
@@ -21,13 +24,65 @@
 	$(LIB)/queue.c \
 	$(LIB)/random.c \
 	$(LIB)/rbtree.c \
+	$(LIB)/hashtable.c \
+	$(LIB)/conc_hashtable.c \
 	$(LIB)/thread.c \
 	$(LIB)/vector.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+CFLAGS += -DUSE_TLH
+
+ifeq ($(enable_IBM_optimizations),yes)
+CFLAGS += -DMAP_USE_CONCUREENT_HASHTABLE -DHASHTABLE_SIZE_FIELD -DHASHTABLE_RESIZABLE
+CFLAGS += -DUSE_RBTREE_FOR_FRAGMENT_REASSEMBLE -DRBTREE_SIZE_FIELD
+else
 CFLAGS += -DMAP_USE_RBTREE
+endif
+
+RUNPARAMS := -a10 -l128 -n262144 -s1
+
+.PHONY:	run1 run2 run4 run6 run8 run12 run16 run32 run64 run128 run-16 run-32 run-64
+
+run1:
+	$(PROGRAM) $(RUNPARAMS) -t1
+
+run2:
+	$(PROGRAM) $(RUNPARAMS) -t2
+
+run4:
+	$(PROGRAM) $(RUNPARAMS) -t4
+
+run6:
+	$(PROGRAM) $(RUNPARAMS) -t6
+
+run8:
+	$(PROGRAM) $(RUNPARAMS) -t8
+
+run12:
+	$(PROGRAM) $(RUNPARAMS) -t12
+
+run16:
+	$(PROGRAM) $(RUNPARAMS) -t16
+
+run32:
+	$(PROGRAM) $(RUNPARAMS) -t32
+
+run64:
+	$(PROGRAM) $(RUNPARAMS) -t64
+
+run128:
+	$(PROGRAM) $(RUNPARAMS) -t128
+
+run-16:
+	$(PROGRAM) $(RUNPARAMS) -t-16
+
+run-32:
+	$(PROGRAM) $(RUNPARAMS) -t-32
 
+run-64:
+	$(PROGRAM) $(RUNPARAMS) -t-64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/intruder/dictionary.c stamp-0.9.10_Distribute/intruder/dictionary.c
--- stamp-0.9.10/intruder/dictionary.c	2008-09-09 07:41:52.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/dictionary.c	2014-12-18 12:19:32.582568680 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <string.h>
@@ -79,6 +80,79 @@
 
 
 char* global_defaultSignatures[] = {
+#ifdef __370__
+    "\x61\x62\x6f\x75\x74",
+    "\x61\x66\x74\x65\x72",
+    "\x61\x6c\x6c",
+    "\x61\x6c\x73\x6f",
+    "\x61\x6e\x64",
+    "\x61\x6e\x79",
+    "\x62\x61\x63\x6b",
+    "\x62\x65\x63\x61\x75\x73\x65",
+    "\x62\x75\x74",
+    "\x63\x61\x6e",
+    "\x63\x6f\x6d\x65",
+    "\x63\x6f\x75\x6c\x64",
+    "\x64\x61\x79",
+    "\x65\x76\x65\x6e",
+    "\x66\x69\x72\x73\x74",
+    "\x66\x6f\x72",
+    "\x66\x72\x6f\x6d",
+    "\x67\x65\x74",
+    "\x67\x69\x76\x65",
+    "\x67\x6f\x6f\x64",
+    "\x68\x61\x76\x65",
+    "\x68\x69\x6d",
+    "\x68\x6f\x77",
+    "\x69\x6e\x74\x6f",
+    "\x69\x74\x73",
+    "\x6a\x75\x73\x74",
+    "\x6b\x6e\x6f\x77",
+    "\x6c\x69\x6b\x65",
+    "\x6c\x6f\x6f\x6b",
+    "\x6d\x61\x6b\x65",
+    "\x6d\x6f\x73\x74",
+    "\x6e\x65\x77",
+    "\x6e\x6f\x74",
+    "\x6e\x6f\x77",
+    "\x6f\x6e\x65",
+    "\x6f\x6e\x6c\x79",
+    "\x6f\x74\x68\x65\x72",
+    "\x6f\x75\x74",
+    "\x6f\x76\x65\x72",
+    "\x70\x65\x6f\x70\x6c\x65",
+    "\x73\x61\x79",
+    "\x73\x65\x65",
+    "\x73\x68\x65",
+    "\x73\x6f\x6d\x65",
+    "\x74\x61\x6b\x65",
+    "\x74\x68\x61\x6e",
+    "\x74\x68\x61\x74",
+    "\x74\x68\x65\x69\x72",
+    "\x74\x68\x65\x6d",
+    "\x74\x68\x65\x6e",
+    "\x74\x68\x65\x72\x65",
+    "\x74\x68\x65\x73\x65",
+    "\x74\x68\x65\x79",
+    "\x74\x68\x69\x6e\x6b",
+    "\x74\x68\x69\x73",
+    "\x74\x69\x6d\x65",
+    "\x74\x77\x6f",
+    "\x75\x73\x65",
+    "\x77\x61\x6e\x74",
+    "\x77\x61\x79",
+    "\x77\x65\x6c\x6c",
+    "\x77\x68\x61\x74",
+    "\x77\x68\x65\x6e",
+    "\x77\x68\x69\x63\x68",
+    "\x77\x68\x6f",
+    "\x77\x69\x6c\x6c",
+    "\x77\x69\x74\x68",
+    "\x77\x6f\x72\x6b",
+    "\x77\x6f\x75\x6c\x64",
+    "\x79\x65\x61\x72",
+    "\x79\x6f\x75\x72"
+#else
     "about",
     "after",
     "all",
@@ -150,6 +224,7 @@
     "would",
     "year",
     "your"
+#endif
 };
 
 const long global_numDefaultSignature =
diff -Naur -x .svn stamp-0.9.10/intruder/intruder.c stamp-0.9.10_Distribute/intruder/intruder.c
--- stamp-0.9.10/intruder/intruder.c	2008-09-09 07:41:53.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/intruder.c	2014-12-18 12:19:41.091574853 +0900
@@ -67,10 +67,15 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include "decoder.h"
@@ -81,6 +86,10 @@
 #include "thread.h"
 #include "timer.h"
 #include "tm.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 enum param_types {
     PARAM_ATTACK = (unsigned char)'a',
@@ -196,7 +205,7 @@
     while (1) {
 
         char* bytes;
-        TM_BEGIN();
+        TM_BEGIN_ID(0);
         bytes = TMSTREAM_GETPACKET(streamPtr);
         TM_END();
         if (!bytes) {
@@ -207,7 +216,7 @@
         long flowId = packetPtr->flowId;
 
         error_t error;
-        TM_BEGIN();
+        TM_BEGIN_ID(1);
         error = TMDECODER_PROCESS(decoderPtr,
                                   bytes,
                                   (PACKET_HEADER_LENGTH + packetPtr->length));
@@ -223,7 +232,7 @@
 
         char* data;
         long decodedFlowId;
-        TM_BEGIN();
+        TM_BEGIN_ID(2);
         data = TMDECODER_GETCOMPLETE(decoderPtr, &decodedFlowId);
         TM_END();
         if (data) {
@@ -257,6 +266,46 @@
      */
 
     parseArgs(argc, (char** const)argv);
+#if defined(__bgq__)
+    if (global_params[PARAM_THREAD] < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -global_params[PARAM_THREAD];
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    global_params[PARAM_THREAD] = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    global_params[PARAM_THREAD] = 2;
+	    break;
+	case 2:
+	    global_params[PARAM_THREAD] = 4;
+	    break;
+	case 3:
+	    global_params[PARAM_THREAD] = 8;
+	    break;
+	case 4:
+	    global_params[PARAM_THREAD] = 16;
+	    break;
+	case 5:
+	    global_params[PARAM_THREAD] = 32;
+	    break;
+	case 6:
+	    global_params[PARAM_THREAD] = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < global_params[PARAM_THREAD]) {
+	    exit(0);
+	}
+    }
+#endif
     long numThread = global_params[PARAM_THREAD];
     SIM_GET_NUM_CPU(numThread);
     TM_STARTUP(numThread);
diff -Naur -x .svn stamp-0.9.10/intruder/Makefile.hle_intel stamp-0.9.10_Distribute/intruder/Makefile.hle_intel
--- stamp-0.9.10/intruder/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/Makefile.hle_intel	2014-12-18 12:37:46.544631936 +0900
@@ -0,0 +1,47 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+.PHONY: test_decoder
+test_decoder: CFLAGS += -DTEST_DECODER -O0
+test_decoder: LIB_SRCS := $(LIB)/{list,mt19937ar,queue,random,rbtree}.c
+test_decoder:
+	$(CC) $(CFLAGS) decoder.c packet.c $(LIB_SRCS) -o $@
+
+.PHONY: test_detector
+test_detector: CFLAGS += -DTEST_DETECTOR -O0
+test_detector: LIB_SRCS := $(LIB)/vector.c
+test_detector:
+	$(CC) $(CFLAGS) detector.c dictionary.c preprocessor.c $(LIB_SRCS) -o $@
+
+.PHONY: test_dictionary
+test_dictionary: CFLAGS += -DTEST_DICTIONARY -O0
+test_dictionary: LIB_SRCS := $(LIB)/vector.c
+test_dictionary:
+	$(CC) $(CFLAGS) dictionary.c $(LIB_SRCS) -o $@
+
+.PHONY: test_preprocessor
+test_preprocessor: CFLAGS += -DTEST_PREPROCESSOR -O0
+test_preprocessor:
+	$(CC) $(CFLAGS) preprocessor.c -o $@
+
+.PHONY: test_stream
+test_stream: CFLAGS += -DTEST_STREAM -O0
+test_stream: LIB_SRCS := $(LIB)/{mt19937ar,pair,queue,random,rbtree,vector}.c
+test_stream:
+	$(CC) $(CFLAGS) stream.c detector.c dictionary.c preprocessor.c $(LIB_SRCS) -o $@
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/intruder/Makefile.htm_ibm stamp-0.9.10_Distribute/intruder/Makefile.htm_ibm
--- stamp-0.9.10/intruder/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/Makefile.htm_ibm	2014-12-18 12:37:53.246627623 +0900
@@ -0,0 +1,47 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+.PHONY: test_decoder
+test_decoder: CFLAGS += -DTEST_DECODER -O0
+test_decoder: LIB_SRCS := $(LIB)/{list,mt19937ar,queue,random,rbtree}.c
+test_decoder:
+	$(CC) $(CFLAGS) decoder.c packet.c $(LIB_SRCS) -o $@
+
+.PHONY: test_detector
+test_detector: CFLAGS += -DTEST_DETECTOR -O0
+test_detector: LIB_SRCS := $(LIB)/vector.c
+test_detector:
+	$(CC) $(CFLAGS) detector.c dictionary.c preprocessor.c $(LIB_SRCS) -o $@
+
+.PHONY: test_dictionary
+test_dictionary: CFLAGS += -DTEST_DICTIONARY -O0
+test_dictionary: LIB_SRCS := $(LIB)/vector.c
+test_dictionary:
+	$(CC) $(CFLAGS) dictionary.c $(LIB_SRCS) -o $@
+
+.PHONY: test_preprocessor
+test_preprocessor: CFLAGS += -DTEST_PREPROCESSOR -O0
+test_preprocessor:
+	$(CC) $(CFLAGS) preprocessor.c -o $@
+
+.PHONY: test_stream
+test_stream: CFLAGS += -DTEST_STREAM -O0
+test_stream: LIB_SRCS := $(LIB)/{mt19937ar,pair,queue,random,rbtree,vector}.c
+test_stream:
+	$(CC) $(CFLAGS) stream.c detector.c dictionary.c preprocessor.c $(LIB_SRCS) -o $@
+	
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/intruder/Makefile.lock stamp-0.9.10_Distribute/intruder/Makefile.lock
--- stamp-0.9.10/intruder/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/Makefile.lock	2014-12-18 12:37:59.102580686 +0900
@@ -0,0 +1,47 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+.PHONY: test_decoder
+test_decoder: CFLAGS += -DTEST_DECODER -O0
+test_decoder: LIB_SRCS := $(LIB)/{list,mt19937ar,queue,random,rbtree}.c
+test_decoder:
+	$(CC) $(CFLAGS) decoder.c packet.c $(LIB_SRCS) -o $@
+
+.PHONY: test_detector
+test_detector: CFLAGS += -DTEST_DETECTOR -O0
+test_detector: LIB_SRCS := $(LIB)/vector.c
+test_detector:
+	$(CC) $(CFLAGS) detector.c dictionary.c preprocessor.c $(LIB_SRCS) -o $@
+
+.PHONY: test_dictionary
+test_dictionary: CFLAGS += -DTEST_DICTIONARY -O0
+test_dictionary: LIB_SRCS := $(LIB)/vector.c
+test_dictionary:
+	$(CC) $(CFLAGS) dictionary.c $(LIB_SRCS) -o $@
+
+.PHONY: test_preprocessor
+test_preprocessor: CFLAGS += -DTEST_PREPROCESSOR -O0
+test_preprocessor:
+	$(CC) $(CFLAGS) preprocessor.c -o $@
+
+.PHONY: test_stream
+test_stream: CFLAGS += -DTEST_STREAM -O0
+test_stream: LIB_SRCS := $(LIB)/{mt19937ar,pair,queue,random,rbtree,vector}.c
+test_stream:
+	$(CC) $(CFLAGS) stream.c detector.c dictionary.c preprocessor.c $(LIB_SRCS) -o $@
+	
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/intruder/preprocessor.c stamp-0.9.10_Distribute/intruder/preprocessor.c
--- stamp-0.9.10/intruder/preprocessor.c	2008-09-09 07:41:53.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/preprocessor.c	2014-12-18 12:19:50.424575583 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -122,7 +123,12 @@
     char* src = str;
 
     while (*src != '\0') {
+#ifdef __370__
+      if ('\x41' <= *src && *src <= '\x5a')
+	*src += 32;
+#else
         *src = (char)tolower((int)*src);
+#endif
         src++;
     }
 }
diff -Naur -x .svn stamp-0.9.10/intruder/stream.c stamp-0.9.10_Distribute/intruder/stream.c
--- stamp-0.9.10/intruder/stream.c	2008-09-09 07:41:53.000000000 +0900
+++ stamp-0.9.10_Distribute/intruder/stream.c	2014-12-18 12:19:55.581754717 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -223,7 +224,11 @@
     random_seed(randomPtr, seed);
     queue_clear(packetQueuePtr);
 
+#ifdef __370__
+    long range = '\x7e' - '\x20' + 1;
+#else
     long range = '~' - ' ' + 1;
+#endif
     assert(range > 0);
 
     long f;
@@ -246,7 +251,11 @@
             assert(status);
             long l;
             for (l = 0; l < length; l++) {
+#ifdef __370__
+                str[l] = '\x20' + (char)(random_generate(randomPtr) % range);
+#else
                 str[l] = ' ' + (char)(random_generate(randomPtr) % range);
+#endif
             }
             str[l] = '\0';
             char* str2 = (char*)malloc((length + 1) * sizeof(char));
diff -Naur -x .svn stamp-0.9.10/kmeans/Defines.common.mk stamp-0.9.10_Distribute/kmeans/Defines.common.mk
--- stamp-0.9.10/kmeans/Defines.common.mk	2008-09-09 07:41:54.000000000 +0900
+++ stamp-0.9.10_Distribute/kmeans/Defines.common.mk	2014-12-18 15:39:21.745678854 +0900
@@ -3,10 +3,19 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+hostname := $(shell hostname)
+
+CFLAGS += -DUSE_TLH
 CFLAGS += -DOUTPUT_TO_STDOUT
 
+ifeq ($(enable_IBM_optimizations),yes)
+CFLAGS += -DALIGNED_ALLOC_MEMORY
+#CFLAGS += -DLARGE_ALIGNMENT
+endif
+
 PROG := kmeans
 
 SRCS += \
@@ -17,9 +26,95 @@
 	$(LIB)/mt19937ar.c \
 	$(LIB)/random.c \
 	$(LIB)/thread.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+RUNPARAMSLOW := -m40 -n40 -t0.00001 -i inputs/random-n65536-d32-c16.txt
+RUNPARAMSHIGH := -m15 -n15 -t0.00001 -i inputs/random-n65536-d32-c16.txt
+
+.PHONY:	runlow1 runlow2 runlow4 runlow6 runlow8 runlow12 runlow16 runlow32 runlow64 runlow128 runlow-16 runlow-32 runlow-64
+
+runlow1:
+	$(PROGRAM) $(RUNPARAMSLOW) -p1
+
+runlow2:
+	$(PROGRAM) $(RUNPARAMSLOW) -p2
+
+runlow4:
+	$(PROGRAM) $(RUNPARAMSLOW) -p4
+
+runlow6:
+	$(PROGRAM) $(RUNPARAMSLOW) -p6
+
+runlow8:
+	$(PROGRAM) $(RUNPARAMSLOW) -p8
+
+runlow12:
+	$(PROGRAM) $(RUNPARAMSLOW) -p12
+
+runlow16:
+	$(PROGRAM) $(RUNPARAMSLOW) -p16
+
+runlow32:
+	$(PROGRAM) $(RUNPARAMSLOW) -p32
+
+runlow64:
+	$(PROGRAM) $(RUNPARAMSLOW) -p64
+
+runlow128:
+	$(PROGRAM) $(RUNPARAMSLOW) -p128
+
+runlow-16:
+	$(PROGRAM) $(RUNPARAMSLOW) -p-16
+
+runlow-32:
+	$(PROGRAM) $(RUNPARAMSLOW) -p-32
+
+runlow-64:
+	$(PROGRAM) $(RUNPARAMSLOW) -p-64
+
+
+.PHONY:	runhigh1 runhigh2 runhigh4 runhigh6 runhigh8 runhigh12 runhigh16 runhigh32 runhigh64 runhigh128 runhigh-16 runhigh-32 runhigh-64
+
+runhigh1:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p1
+
+runhigh2:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p2
+
+runhigh4:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p4
+
+runhigh6:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p6
+
+runhigh8:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p8
+
+runhigh12:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p12
+
+runhigh16:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p16
+
+runhigh32:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p32
+
+runhigh64:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p64
+
+runhigh128:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p128
+
+runhigh-16:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p-16
+
+runhigh-32:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p-32
+
+runhigh-64:
+	$(PROGRAM) $(RUNPARAMSHIGH) -p-64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/kmeans/kmeans.c stamp-0.9.10_Distribute/kmeans/kmeans.c
--- stamp-0.9.10/kmeans/kmeans.c	2008-09-09 07:41:54.000000000 +0900
+++ stamp-0.9.10_Distribute/kmeans/kmeans.c	2014-12-18 12:20:04.629586536 +0900
@@ -91,11 +91,16 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
 #include <fcntl.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -108,6 +113,10 @@
 #include "thread.h"
 #include "tm.h"
 #include "util.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 #define MAX_LINE_LENGTH 1000000 /* max input is 400000 one digit input + spaces */
 
@@ -189,6 +198,46 @@
                       break;
         }
     }
+#if defined(__bgq__)
+    if (nthreads < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -nthreads;
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    nthreads = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    nthreads = 2;
+	    break;
+	case 2:
+	    nthreads = 4;
+	    break;
+	case 3:
+	    nthreads = 8;
+	    break;
+	case 4:
+	    nthreads = 16;
+	    break;
+	case 5:
+	    nthreads = 32;
+	    break;
+	case 6:
+	    nthreads = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < nthreads) {
+	    exit(0);
+	}
+    }
+#endif
 
     if (filename == 0) {
         usage((char*)argv[0]);
diff -Naur -x .svn stamp-0.9.10/kmeans/Makefile.hle_intel stamp-0.9.10_Distribute/kmeans/Makefile.hle_intel
--- stamp-0.9.10/kmeans/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/kmeans/Makefile.hle_intel	2014-12-18 12:38:32.455573471 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/kmeans/Makefile.htm_ibm stamp-0.9.10_Distribute/kmeans/Makefile.htm_ibm
--- stamp-0.9.10/kmeans/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/kmeans/Makefile.htm_ibm	2014-12-18 12:38:37.761586534 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/kmeans/Makefile.lock stamp-0.9.10_Distribute/kmeans/Makefile.lock
--- stamp-0.9.10/kmeans/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/kmeans/Makefile.lock	2014-12-18 12:38:43.311696413 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/kmeans/normal.c stamp-0.9.10_Distribute/kmeans/normal.c
--- stamp-0.9.10/kmeans/normal.c	2008-09-09 07:41:54.000000000 +0900
+++ stamp-0.9.10_Distribute/kmeans/normal.c	2014-12-18 12:20:22.069722640 +0900
@@ -80,6 +80,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -87,6 +88,9 @@
 #include <stdlib.h>
 #include <float.h>
 #include <math.h>
+#ifdef ALIGNED_ALLOC_MEMORY
+#include <string.h>
+#endif
 #include "common.h"
 #include "normal.h"
 #include "random.h"
@@ -165,7 +169,7 @@
             membership[i] = index;
 
             /* Update new cluster centers : sum of objects located within */
-            TM_BEGIN();
+            TM_BEGIN_ID(0);
             TM_SHARED_WRITE(*new_centers_len[index],
                             TM_SHARED_READ(*new_centers_len[index]) + 1);
             for (j = 0; j < nfeatures; j++) {
@@ -179,7 +183,7 @@
 
         /* Update task queue */
         if (start + CHUNK < npoints) {
-            TM_BEGIN();
+            TM_BEGIN_ID(1);
             start = (int)TM_SHARED_READ(global_i);
             TM_SHARED_WRITE(global_i, (start + CHUNK));
             TM_END();
@@ -188,7 +192,7 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(2);
     TM_SHARED_WRITE_F(global_delta, TM_SHARED_READ_F(global_delta) + delta);
     TM_END();
 
@@ -218,6 +222,9 @@
     float** clusters;      /* out: [nclusters][nfeatures] */
     float** new_centers;   /* [nclusters][nfeatures] */
     void* alloc_memory = NULL;
+#ifdef ALIGNED_ALLOC_MEMORY
+    void *aligned_alloc_memory;
+#endif
     args_t args;
     TIMER_T start;
     TIMER_T stop;
@@ -249,15 +256,42 @@
      */
     {
         int cluster_size = sizeof(int) + sizeof(float) * nfeatures;
+#if defined(LARGE_ALIGNMENT)
+        const int cacheLineSize = 1048576;
+#elif defined( __370__)
+        const int cacheLineSize = 256;
+#elif defined(__bgq__)
+        const int cacheLineSize = 128;
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+        const int cacheLineSize = 128;
+#elif defined(__x86_64__)
+        const int cacheLineSize = 64;
+#else
         const int cacheLineSize = 32;
+#endif
         cluster_size += (cacheLineSize-1) - ((cluster_size-1) % cacheLineSize);
+#ifdef ALIGNED_ALLOC_MEMORY
+#ifdef LARGE_ALIGNMENT
+        alloc_memory = malloc(nclusters * cluster_size + cacheLineSize * 2);
+#else
+        alloc_memory = malloc(nclusters * cluster_size + cacheLineSize);
+#endif
+	aligned_alloc_memory = (void *)(((uintptr_t)alloc_memory + cacheLineSize - 1) & ~(cacheLineSize - 1));
+	memset(aligned_alloc_memory, 0, nclusters * cluster_size);
+#else
         alloc_memory = calloc(nclusters, cluster_size);
+#endif
         new_centers_len = (int**) malloc(nclusters * sizeof(int*));
         new_centers = (float**) malloc(nclusters * sizeof(float*));
         assert(alloc_memory && new_centers && new_centers_len);
         for (i = 0; i < nclusters; i++) {
+#ifdef ALIGNED_ALLOC_MEMORY
+            new_centers_len[i] = (int*)((char*)aligned_alloc_memory + cluster_size * i);
+            new_centers[i] = (float*)((char*)aligned_alloc_memory + cluster_size * i + sizeof(int));
+#else
             new_centers_len[i] = (int*)((char*)alloc_memory + cluster_size * i);
             new_centers[i] = (float*)((char*)alloc_memory + cluster_size * i + sizeof(int));
+#endif
         }
     }
 
diff -Naur -x .svn stamp-0.9.10/labyrinth/Defines.common.mk stamp-0.9.10_Distribute/labyrinth/Defines.common.mk
--- stamp-0.9.10/labyrinth/Defines.common.mk	2008-09-09 07:42:37.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/Defines.common.mk	2014-12-18 12:38:55.739712314 +0900
@@ -3,8 +3,11 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+hostname := $(shell hostname)
+
 LIBS += -lm
 
 PROG := labyrinth
@@ -22,11 +25,55 @@
 	$(LIB)/random.c \
 	$(LIB)/thread.c \
 	$(LIB)/vector.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+CFLAGS += -DUSE_TLH
 CFLAGS += -DUSE_EARLY_RELEASE
 
+RUNPARAMS := -i inputs/random-x512-y512-z7-n512.txt -t
+
+.PHONY:	run1 run2 run4 run6 run8 run12 run16 run32 run64 run128 run-16 run-32 run-64
+
+run1:
+	$(PROGRAM) $(RUNPARAMS) 1
+
+run2:
+	$(PROGRAM) $(RUNPARAMS) 2
+
+run4:
+	$(PROGRAM) $(RUNPARAMS) 4
+
+run6:
+	$(PROGRAM) $(RUNPARAMS) 6
+
+run8:
+	$(PROGRAM) $(RUNPARAMS) 8
+
+run12:
+	$(PROGRAM) $(RUNPARAMS) 12
+
+run16:
+	$(PROGRAM) $(RUNPARAMS) 16
+
+run32:
+	$(PROGRAM) $(RUNPARAMS) 32
+
+run64:
+	$(PROGRAM) $(RUNPARAMS) 64
+
+run128:
+	$(PROGRAM) $(RUNPARAMS) 128
+
+run-16:
+	$(PROGRAM) $(RUNPARAMS) -16
+
+run-32:
+	$(PROGRAM) $(RUNPARAMS) -32
+
+run-64:
+	$(PROGRAM) $(RUNPARAMS) -64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/labyrinth/grid.c stamp-0.9.10_Distribute/labyrinth/grid.c
--- stamp-0.9.10/labyrinth/grid.c	2008-09-09 07:42:37.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/grid.c	2014-12-18 12:20:38.544719822 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -80,7 +81,17 @@
 #include "vector.h"
 
 
+#if defined( __370__)
+const unsigned long CACHE_LINE_SIZE = 256UL;
+#elif defined(__bgq__)
+const unsigned long CACHE_LINE_SIZE = 128UL;
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+const unsigned long CACHE_LINE_SIZE = 128UL;
+#elif defined(__x86_64__)
+const unsigned long CACHE_LINE_SIZE = 64UL;
+#else
 const unsigned long CACHE_LINE_SIZE = 32UL;
+#endif
 
 
 /* =============================================================================
diff -Naur -x .svn stamp-0.9.10/labyrinth/labyrinth.c stamp-0.9.10_Distribute/labyrinth/labyrinth.c
--- stamp-0.9.10/labyrinth/labyrinth.c	2008-09-09 07:42:37.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/labyrinth.c	2014-12-18 12:20:30.266573161 +0900
@@ -67,10 +67,15 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include "list.h"
@@ -79,6 +84,10 @@
 #include "thread.h"
 #include "timer.h"
 #include "types.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 enum param_types {
     PARAM_BENDCOST = (unsigned char)'b',
@@ -195,6 +204,46 @@
      * Initialization
      */
     parseArgs(argc, (char** const)argv);
+#if defined(__bgq__)
+    if (global_params[PARAM_THREAD] < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -global_params[PARAM_THREAD];
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    global_params[PARAM_THREAD] = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    global_params[PARAM_THREAD] = 2;
+	    break;
+	case 2:
+	    global_params[PARAM_THREAD] = 4;
+	    break;
+	case 3:
+	    global_params[PARAM_THREAD] = 8;
+	    break;
+	case 4:
+	    global_params[PARAM_THREAD] = 16;
+	    break;
+	case 5:
+	    global_params[PARAM_THREAD] = 32;
+	    break;
+	case 6:
+	    global_params[PARAM_THREAD] = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < global_params[PARAM_THREAD]) {
+	    exit(0);
+	}
+    }
+#endif
     long numThread = global_params[PARAM_THREAD];
     SIM_GET_NUM_CPU(numThread);
     TM_STARTUP(numThread);
diff -Naur -x .svn stamp-0.9.10/labyrinth/Makefile.hle_intel stamp-0.9.10_Distribute/labyrinth/Makefile.hle_intel
--- stamp-0.9.10/labyrinth/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/Makefile.hle_intel	2014-12-18 12:39:02.784566989 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/labyrinth/Makefile.htm_ibm stamp-0.9.10_Distribute/labyrinth/Makefile.htm_ibm
--- stamp-0.9.10/labyrinth/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/Makefile.htm_ibm	2014-12-18 12:39:14.282622267 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/labyrinth/Makefile.lock stamp-0.9.10_Distribute/labyrinth/Makefile.lock
--- stamp-0.9.10/labyrinth/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/Makefile.lock	2014-12-18 12:39:19.966644092 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/labyrinth/router.c stamp-0.9.10_Distribute/labyrinth/router.c
--- stamp-0.9.10/labyrinth/router.c	2008-09-09 07:42:38.000000000 +0900
+++ stamp-0.9.10_Distribute/labyrinth/router.c	2014-12-18 12:20:47.050592473 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -376,7 +377,7 @@
     while (1) {
 
         pair_t* coordinatePairPtr;
-        TM_BEGIN();
+        TM_BEGIN_ID(0);
         if (TMQUEUE_ISEMPTY(workQueuePtr)) {
             coordinatePairPtr = NULL;
         } else {
@@ -393,7 +394,7 @@
         bool_t success = FALSE;
         vector_t* pointVectorPtr = NULL;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(1);
         grid_copy(myGridPtr, gridPtr); /* ok if not most up-to-date */
         if (PdoExpansion(routerPtr, myGridPtr, myExpansionQueuePtr,
                          srcPtr, dstPtr)) {
@@ -422,7 +423,7 @@
      * Add my paths to global list
      */
     list_t* pathVectorListPtr = routerArgPtr->pathVectorListPtr;
-    TM_BEGIN();
+    TM_BEGIN_ID(2);
     TMLIST_INSERT(pathVectorListPtr, (void*)myPathVectorPtr);
     TM_END();
 
diff -Naur -x .svn stamp-0.9.10/lib/bitmap.c stamp-0.9.10_Distribute/lib/bitmap.c
--- stamp-0.9.10/lib/bitmap.c	2008-09-09 07:42:39.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/bitmap.c	2014-12-18 12:20:56.962723495 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -98,7 +99,11 @@
     }
 
     bitmapPtr->numBit = numBit;
+#ifdef __GNUC__
     long numWord = DIVIDE_AND_ROUND_UP(numBit, NUM_BIT_PER_WORD);
+#else
+    long numWord = DIVIDE_AND_ROUND_UP_nogcc(numBit, NUM_BIT_PER_WORD);
+#endif
     bitmapPtr->numWord = numWord;
 
     bitmapPtr->bits = (ulong_t*)malloc(numWord * sizeof(ulong_t));
@@ -127,7 +132,11 @@
     }
 
     bitmapPtr->numBit = numBit;
+#ifdef __GNUC__
     long numWord = DIVIDE_AND_ROUND_UP(numBit, NUM_BIT_PER_WORD);
+#else
+    long numWord = DIVIDE_AND_ROUND_UP_nogcc(numBit, NUM_BIT_PER_WORD);
+#endif
     bitmapPtr->numWord = numWord;
 
     bitmapPtr->bits = (ulong_t*)P_MALLOC(numWord * sizeof(ulong_t));
@@ -264,7 +273,11 @@
     long numBit = bitmapPtr->numBit;
     ulong_t* bits = bitmapPtr->bits;
 
+#ifdef __GNUC__
     for (i = MAX(startIndex, 0); i < numBit; i++) {
+#else
+    for (i = MAX_nogcc(startIndex, 0); i < numBit; i++) {
+#endif
         if (!(bits[i/NUM_BIT_PER_WORD] & (1UL << (i % NUM_BIT_PER_WORD)))) {
             return i;
         }
@@ -288,7 +301,11 @@
     long numBit = bitmapPtr->numBit;
     ulong_t* bits = bitmapPtr->bits;
 
+#ifdef __GNUC__
     for (i = MAX(startIndex, 0); i < numBit; i++) {
+#else
+    for (i = MAX_nogcc(startIndex, 0); i < numBit; i++) {
+#endif
         if (bits[i/NUM_BIT_PER_WORD] & (1UL << (i % NUM_BIT_PER_WORD))) {
             return i;
         }
@@ -388,7 +405,11 @@
     bitmapPtr = bitmap_alloc(numBit);
 
     assert(bitmapPtr->numBit == numBit);
+#ifdef __GNUC__
     assert(bitmapPtr->numWord == (DIVIDE_AND_ROUND_UP(numBit, NUM_BIT_PER_WORD)));
+#else
+    assert(bitmapPtr->numWord == (DIVIDE_AND_ROUND_UP_nogcc(numBit, NUM_BIT_PER_WORD)));
+#endif
 
     /* Check that initial is all clear */
     for (i = 0; i < numBit; i++) {
diff -Naur -x .svn stamp-0.9.10/lib/conc_hashtable.c stamp-0.9.10_Distribute/lib/conc_hashtable.c
--- stamp-0.9.10/lib/conc_hashtable.c	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/conc_hashtable.c	2014-12-18 12:21:04.570632755 +0900
@@ -0,0 +1,220 @@
+/* Copyright (c) IBM Corp. 2014. */
+#include <stdlib.h>
+#include <stdint.h>
+#include "conc_hashtable.h"
+#include "types.h"
+
+#ifdef HAVE_CONFIG_H
+# include "STAMP_config.h"
+#endif
+
+#if defined( __370__)
+#define CACHE_LINE_SIZE 256
+#elif defined(__bgq__)
+#define CACHE_LINE_SIZE 128
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define CACHE_LINE_SIZE 128
+#elif defined(__x86_64__)
+#define CACHE_LINE_SIZE 64
+#else
+#define CACHE_LINE_SIZE 32
+#endif
+
+#define ALIGNED_HASHTABLE_SIZE ((sizeof(hashtable_t) + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1))
+
+#define NUM_SEGMENTS 31
+#define GET_SEGMENT(seg, idx) ((hashtable_t *)((char *)(seg) + ALIGNED_HASHTABLE_SIZE * (idx)))
+
+static ulong_t
+hashKeyDefault(const void *a)
+{
+    return (ulong_t)a;
+}
+
+static long
+comparePairsDefault (const pair_t* a, const pair_t* b)
+{
+    return ((long)(a->firstPtr) - (long)(b->firstPtr));
+}
+
+conc_hashtable_t*
+conc_hashtable_alloc (long initNumBucket,
+		      ulong_t (*hash)(const void*),
+		      long (*comparePairs)(const pair_t*, const pair_t*),
+		      long resizeRatio,
+		      long growthFactor)
+{
+    conc_hashtable_t *concHashtablePtr;
+    char *segmentsUnaligned;
+    char *segments;
+    int s;
+
+    if (hash == NULL) {
+	hash = hashKeyDefault;
+    }
+    if (comparePairs == NULL) {
+	comparePairs = comparePairsDefault;
+    }
+
+    concHashtablePtr = (conc_hashtable_t *)malloc(sizeof(conc_hashtable_t));
+    if (concHashtablePtr == NULL) {
+	return NULL;
+    }
+
+    concHashtablePtr->hash = hash;
+
+    segmentsUnaligned = (char *)malloc(sizeof(char) * ALIGNED_HASHTABLE_SIZE * NUM_SEGMENTS + CACHE_LINE_SIZE);
+    if (segmentsUnaligned == NULL) {
+	return NULL;
+    }
+    segments = (char *)(((uintptr_t)segmentsUnaligned + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1));
+
+    concHashtablePtr->segmentsUnaligned = segmentsUnaligned;
+    concHashtablePtr->segments = segments;
+
+    for (s = 0; s < NUM_SEGMENTS; s++) {
+	if (hashtable_init(GET_SEGMENT(segments, s),
+			   initNumBucket, hash, comparePairs, resizeRatio, growthFactor)) {
+	    free(concHashtablePtr);
+	    return NULL;
+	}
+    }
+
+    return concHashtablePtr;
+}
+
+void
+conc_hashtable_free (conc_hashtable_t* concHashtablePtr)
+{
+    int s;
+
+    for (s = 0; s < NUM_SEGMENTS; s++) {
+	hashtable_free_buckets(GET_SEGMENT(concHashtablePtr->segments, s));
+    }
+
+    free(concHashtablePtr->segmentsUnaligned);
+    free(concHashtablePtr);
+}
+
+bool_t
+conc_hashtable_containsKey (conc_hashtable_t* concHashtablePtr, void* keyPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return hashtable_containsKey(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr);
+}
+
+
+void*
+conc_hashtable_find (conc_hashtable_t* concHashtablePtr, void* keyPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return hashtable_find(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr);
+}
+
+bool_t
+conc_hashtable_insert (conc_hashtable_t* concHashtablePtr, void* keyPtr, void* dataPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return hashtable_insert(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr, dataPtr);
+}
+
+bool_t
+conc_hashtable_remove (conc_hashtable_t* concHashtablePtr, void* keyPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return hashtable_remove(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr);
+}
+
+
+
+conc_hashtable_t*
+TMconc_hashtable_alloc (TM_ARGDECL  long initNumBucket,
+			ulong_t (*hash)(const void*),
+			long (*comparePairs)(const pair_t*, const pair_t*),
+			long resizeRatio,
+			long growthFactor)
+{
+    conc_hashtable_t *concHashtablePtr;
+    char *segmentsUnaligned;
+    char *segments;
+    int s;
+
+    if (hash == NULL) {
+	hash = hashKeyDefault;
+    }
+    if (comparePairs == NULL) {
+	comparePairs = comparePairsDefault;
+    }
+
+    /* This will be freed only by TMconc_hashtable_free(),
+       so it can be allocated by malloc(), not TM_MALLOC(). */
+    concHashtablePtr = (conc_hashtable_t *)malloc(sizeof(conc_hashtable_t));
+    if (concHashtablePtr == NULL) {
+	return NULL;
+    }
+
+    concHashtablePtr->hash = hash;
+
+    /* This will be freed only by TMconc_hashtable_free(),
+       so it can be allocated by malloc(), not TM_MALLOC(). */
+    segmentsUnaligned = (char *)malloc(sizeof(char) * ALIGNED_HASHTABLE_SIZE * NUM_SEGMENTS + CACHE_LINE_SIZE);
+    if (segmentsUnaligned == NULL) {
+	return NULL;
+    }
+    segments = (char *)(((uintptr_t)segmentsUnaligned + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1));
+
+    concHashtablePtr->segmentsUnaligned = segmentsUnaligned;
+    concHashtablePtr->segments = segments;
+
+    for (s = 0; s < NUM_SEGMENTS; s++) {
+	if (TMhashtable_init(TM_ARG  GET_SEGMENT(segments, s),
+			     initNumBucket, hash, comparePairs, resizeRatio, growthFactor)) {
+	    free(concHashtablePtr);
+	    return NULL;
+	}
+    }
+
+    return concHashtablePtr;
+}
+
+void
+TMconc_hashtable_free (TM_ARGDECL  conc_hashtable_t* concHashtablePtr)
+{
+    int s;
+
+    for (s = 0; s < NUM_SEGMENTS; s++) {
+	TMhashtable_free_buckets(TM_ARG  GET_SEGMENT(concHashtablePtr->segments, s));
+    }
+
+    free(concHashtablePtr->segmentsUnaligned);
+    free(concHashtablePtr);
+}
+
+bool_t
+TMconc_hashtable_containsKey (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return TMhashtable_containsKey(TM_ARG  GET_SEGMENT(concHashtablePtr->segments, i), keyPtr);
+}
+
+
+void*
+TMconc_hashtable_find (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return TMHASHTABLE_FIND(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr);
+}
+
+bool_t
+TMconc_hashtable_insert (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr, void* dataPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return TMHASHTABLE_INSERT(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr, dataPtr);
+}
+
+bool_t
+TMconc_hashtable_remove (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr)
+{
+    long i = concHashtablePtr->hash(keyPtr) % NUM_SEGMENTS;
+    return TMHASHTABLE_REMOVE(GET_SEGMENT(concHashtablePtr->segments, i), keyPtr);
+}
diff -Naur -x .svn stamp-0.9.10/lib/conc_hashtable.h stamp-0.9.10_Distribute/lib/conc_hashtable.h
--- stamp-0.9.10/lib/conc_hashtable.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/conc_hashtable.h	2014-12-18 12:21:09.247782526 +0900
@@ -0,0 +1,78 @@
+/* Copyright (c) IBM Corp. 2014. */
+#ifndef CONC_HASHTABLE_H
+#define CONC_HASHTABLE_H 1
+
+#include "hashtable.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct conc_hashtable {
+    char *segments;
+    char *segmentsUnaligned;
+    ulong_t (*hash)(const void*);
+} conc_hashtable_t;
+
+conc_hashtable_t*
+conc_hashtable_alloc (long initNumBucket,
+		      ulong_t (*hash)(const void*),
+		      long (*comparePairs)(const pair_t*, const pair_t*),
+		      long resizeRatio,
+		      long growthFactor);
+
+void
+conc_hashtable_free (conc_hashtable_t* concHashtablePtr);
+
+bool_t
+conc_hashtable_containsKey (conc_hashtable_t* concHashtablePtr, void* keyPtr);
+
+void*
+conc_hashtable_find (conc_hashtable_t* concHashtablePtr, void* keyPtr);
+
+bool_t
+conc_hashtable_insert (conc_hashtable_t* concHashtablePtr, void* keyPtr, void* dataPtr);
+
+bool_t
+conc_hashtable_remove (conc_hashtable_t* concHashtablePtr, void* keyPtr);
+
+
+
+conc_hashtable_t*
+TMconc_hashtable_alloc (TM_ARGDECL
+			long initNumBucket,
+			ulong_t (*hash)(const void*),
+			long (*comparePairs)(const pair_t*, const pair_t*),
+			long resizeRatio,
+			long growthFactor);
+
+void
+TMconc_hashtable_free (TM_ARGDECL  conc_hashtable_t* concHashtablePtr);
+
+bool_t
+TMconc_hashtable_containsKey (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr);
+
+void*
+TMconc_hashtable_find (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr);
+
+bool_t
+TMconc_hashtable_insert (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr, void* dataPtr);
+
+bool_t
+TMconc_hashtable_remove (TM_ARGDECL  conc_hashtable_t* concHashtablePtr, void* keyPtr);
+
+
+
+#define TMCONC_HASHTABLE_ALLOC(i, h, c, r, g)  TMconc_hashtable_alloc(TM_ARG  i, h, c, r, g)
+#define TMCONC_HASHTABLE_FREE(ht)              TMconc_hashtable_free(TM_ARG  ht)
+#define TMCONC_HASHTABLE_CONTAINSKEY(ht, k)    TMconc_hashtable_containsKey(TM_ARG ht, k)
+#define TMCONC_HASHTABLE_FIND(ht, k)           TMconc_hashtable_find(TM_ARG ht, k)
+#define TMCONC_HASHTABLE_INSERT(ht, k, d)      TMconc_hashtable_insert(TM_ARG ht, k, d)
+#define TMCONC_HASHTABLE_REMOVE(ht, k)         TMconc_hashtable_remove(TM_ARG ht, k)
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* CONC_HASHTABLE_H */
diff -Naur -x .svn stamp-0.9.10/lib/hashtable.c stamp-0.9.10_Distribute/lib/hashtable.c
--- stamp-0.9.10/lib/hashtable.c	2008-09-09 07:42:39.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/hashtable.c	2014-12-18 12:21:26.959755208 +0900
@@ -79,6 +79,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -93,7 +94,7 @@
 #endif
 
 #if defined(HASHTABLE_RESIZABLE) && (defined(HTM) || defined(STM))
-#  warning "hash table resizing currently disabled for TM"
+/*#  warning "hash table resizing currently disabled for TM"*/
 #endif
 
 
@@ -343,6 +344,33 @@
     return hashtablePtr;
 }
 
+int
+hashtable_init (hashtable_t* hashtablePtr,
+		long initNumBucket,
+		ulong_t (*hash)(const void*),
+		long (*comparePairs)(const pair_t*, const pair_t*),
+		long resizeRatio,
+		long growthFactor)
+{
+    hashtablePtr->buckets = allocBuckets(initNumBucket, comparePairs);
+    if (hashtablePtr->buckets == NULL) {
+        return 1;
+    }
+
+    hashtablePtr->numBucket = initNumBucket;
+#ifdef HASHTABLE_SIZE_FIELD
+    hashtablePtr->size = 0;
+#endif
+    hashtablePtr->hash = hash;
+    hashtablePtr->comparePairs = comparePairs;
+    hashtablePtr->resizeRatio = ((resizeRatio < 0) ?
+                                  HASHTABLE_DEFAULT_RESIZE_RATIO : resizeRatio);
+    hashtablePtr->growthFactor = ((growthFactor < 0) ?
+                                  HASHTABLE_DEFAULT_GROWTH_FACTOR : growthFactor);
+
+    return 0;
+}
+
 
 /* =============================================================================
  * TMhashtable_alloc
@@ -385,6 +413,34 @@
     return hashtablePtr;
 }
 
+int
+TMhashtable_init (TM_ARGDECL
+		  hashtable_t* hashtablePtr,
+		  long initNumBucket,
+		  ulong_t (*hash)(const void*),
+		  long (*comparePairs)(const pair_t*, const pair_t*),
+		  long resizeRatio,
+		  long growthFactor)
+{
+    hashtablePtr->buckets = TMallocBuckets(TM_ARG  initNumBucket, comparePairs);
+    if (hashtablePtr->buckets == NULL) {
+        return 1;
+    }
+
+    hashtablePtr->numBucket = initNumBucket;
+#ifdef HASHTABLE_SIZE_FIELD
+    hashtablePtr->size = 0;
+#endif
+    hashtablePtr->hash = hash;
+    hashtablePtr->comparePairs = comparePairs;
+    hashtablePtr->resizeRatio = ((resizeRatio < 0) ?
+                                  HASHTABLE_DEFAULT_RESIZE_RATIO : resizeRatio);
+    hashtablePtr->growthFactor = ((growthFactor < 0) ?
+                                  HASHTABLE_DEFAULT_GROWTH_FACTOR : growthFactor);
+
+    return 0;
+}
+
 
 /* =============================================================================
  * freeBuckets
@@ -431,6 +487,12 @@
     free(hashtablePtr);
 }
 
+void
+hashtable_free_buckets (hashtable_t* hashtablePtr)
+{
+    freeBuckets(hashtablePtr->buckets, hashtablePtr->numBucket);
+}
+
 
 /* =============================================================================
  * TMhashtable_free
@@ -443,6 +505,13 @@
     TM_FREE(hashtablePtr);
 }
 
+void
+TMhashtable_free_buckets (TM_ARGDECL  hashtable_t* hashtablePtr)
+{
+    /*printf("numBucket %ld  size %ld\n", hashtablePtr->numBucket, hashtablePtr->size);*/
+    TMfreeBuckets(TM_ARG  hashtablePtr->buckets, hashtablePtr->numBucket);
+}
+
 
 /* =============================================================================
  * hashtable_isEmpty
@@ -616,7 +685,10 @@
 }
 
 
-#if defined(HASHTABLE_RESIZABLE) && !(defined(HTM) || defined(STM))
+/* Modified by Odaira begin */
+#if defined(HASHTABLE_RESIZABLE)
+/*#if defined(HASHTABLE_RESIZABLE) && !(defined(HTM) || defined(STM) || defined(HTM_IBM) || defined(HLE_INTEL))*/
+/* Modified by Odaira end */
 /* =============================================================================
  * rehash
  * =============================================================================
@@ -652,6 +724,42 @@
 }
 #endif /* HASHTABLE_RESIZABLE */
 
+#if defined(HASHTABLE_RESIZABLE)
+/* =============================================================================
+ * TMrehash
+ * =============================================================================
+ */
+static list_t**
+TMrehash (TM_ARGDECL  hashtable_t* hashtablePtr)
+{
+    list_t** oldBuckets = TM_SHARED_READ(hashtablePtr->buckets);
+    long oldNumBucket = TM_SHARED_READ(hashtablePtr->numBucket);
+    long newNumBucket = hashtablePtr->growthFactor * oldNumBucket;
+    list_t** newBuckets;
+    long i;
+
+    newBuckets = TMallocBuckets(TM_ARG  newNumBucket, hashtablePtr->comparePairs);
+    if (newBuckets == NULL) {
+        return NULL;
+    }
+
+    for (i = 0; i < oldNumBucket; i++) {
+        list_t* chainPtr = TM_SHARED_READ(oldBuckets[i]);
+        list_iter_t it;
+        TMLIST_ITER_RESET(&it, chainPtr);
+        while (TMLIST_ITER_HASNEXT(&it, chainPtr)) {
+            pair_t* transferPtr = (pair_t*)TMLIST_ITER_NEXT(&it, chainPtr);
+            long j = hashtablePtr->hash(transferPtr->firstPtr) % newNumBucket;
+            if (TMLIST_INSERT(newBuckets[j], (void*)transferPtr) == FALSE) {
+                return NULL;
+            }
+        }
+    }
+
+    return newBuckets;
+}
+#endif /* HASHTABLE_RESIZABLE */
+
 
 /* =============================================================================
  * hashtable_insert
@@ -723,12 +831,24 @@
 TMhashtable_insert (TM_ARGDECL
                     hashtable_t* hashtablePtr, void* keyPtr, void* dataPtr)
 {
+#ifdef HASHTABLE_SIZE_FIELD
+    long numBucket = TM_SHARED_READ(hashtablePtr->numBucket);
+#else
     long numBucket = hashtablePtr->numBucket;
+#endif
     long i = hashtablePtr->hash(keyPtr) % numBucket;
+#if defined(HASHTABLE_SIZE_FIELD) || defined(HASHTABLE_RESIZABLE)
+    long newSize;
+#endif
 
     pair_t findPair;
     findPair.firstPtr = keyPtr;
+#ifdef HASHTABLE_SIZE_FIELD
+    list_t **buckets = TM_SHARED_READ(hashtablePtr->buckets);
+    pair_t* pairPtr = (pair_t*)TMLIST_FIND(TM_SHARED_READ(buckets[i]), &findPair);
+#else
     pair_t* pairPtr = (pair_t*)TMLIST_FIND(hashtablePtr->buckets[i], &findPair);
+#endif
     if (pairPtr != NULL) {
         return FALSE;
     }
@@ -738,15 +858,47 @@
         return FALSE;
     }
 
+#ifdef HASHTABLE_SIZE_FIELD
+    newSize = TM_SHARED_READ(hashtablePtr->size) + 1;
+    assert(newSize > 0);
+#elif defined(HASHTABLE_RESIZABLE)
+    newSize = TMHASHTABLE_GETSIZE(hashtablePtr) + 1;
+    assert(newSize > 0);
+#endif
+
+#ifdef HASHTABLE_RESIZABLE
+    /* Increase number of buckets to maintain size ratio */
+    if (newSize >= (numBucket * hashtablePtr->resizeRatio)) {
+        list_t** newBuckets = TMrehash(TM_ARG  hashtablePtr);
+        if (newBuckets == NULL) {
+            return FALSE;
+        }
+        TMfreeBuckets(TM_ARG  hashtablePtr->buckets, numBucket);
+        numBucket *= hashtablePtr->growthFactor;
+	TM_SHARED_WRITE(hashtablePtr->buckets, newBuckets);
+        TM_SHARED_WRITE(hashtablePtr->numBucket, numBucket);
+        i = hashtablePtr->hash(keyPtr) % numBucket;
+
+    }
+#endif
+
     /* Add new entry  */
+#ifdef HASHTABLE_SIZE_FIELD
+    buckets = TM_SHARED_READ(hashtablePtr->buckets);
+    if (TMLIST_INSERT(TM_SHARED_READ(buckets[i]), insertPtr) == FALSE) {
+        TMPAIR_FREE(insertPtr);
+        return FALSE;
+    }
+#else
     if (TMLIST_INSERT(hashtablePtr->buckets[i], insertPtr) == FALSE) {
         TMPAIR_FREE(insertPtr);
         return FALSE;
     }
+#endif
 
 #ifdef HASHTABLE_SIZE_FIELD
-    long newSize = TM_SHARED_READ(hashtablePtr->size) + 1;
-    assert(newSize > 0);
+    /*long newSize = TM_SHARED_READ(hashtablePtr->size) + 1;
+    assert(newSize > 0);*/
     TM_SHARED_WRITE(hashtablePtr->size, newSize);
 #endif
 
@@ -812,7 +964,7 @@
     TMPAIR_FREE(pairPtr);
 
 #ifdef HASHTABLE_SIZE_FIELD
-    TM_SHARED_WRITE(hashtablePtr->size
+    TM_SHARED_WRITE(hashtablePtr->size,
                     (long)TM_SHARED_READ(hashtablePtr->size)-1);
     assert(hashtablePtr->size >= 0);
 #endif
diff -Naur -x .svn stamp-0.9.10/lib/hashtable.h stamp-0.9.10_Distribute/lib/hashtable.h
--- stamp-0.9.10/lib/hashtable.h	2008-09-09 07:42:39.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/hashtable.h	2014-12-18 12:21:33.726755408 +0900
@@ -79,6 +79,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef HASHTABLE_H
@@ -185,6 +186,13 @@
                  long resizeRatio,
                  long growthFactor);
 
+int
+hashtable_init (hashtable_t* hashtablePtr,
+		long initNumBucket,
+		ulong_t (*hash)(const void*),
+		long (*comparePairs)(const pair_t*, const pair_t*),
+		long resizeRatio,
+		long growthFactor);
 
 /* =============================================================================
  * TMhashtable_alloc
@@ -200,6 +208,15 @@
                    long resizeRatio,
                    long growthFactor);
 
+int
+TMhashtable_init (TM_ARGDECL
+		  hashtable_t* hashtablePtr,
+		  long initNumBucket,
+		  ulong_t (*hash)(const void*),
+		  long (*comparePairs)(const pair_t*, const pair_t*),
+		  long resizeRatio,
+		  long growthFactor);
+
 
 /* =============================================================================
  * hashtable_free
@@ -208,6 +225,9 @@
 void
 hashtable_free (hashtable_t* hashtablePtr);
 
+void
+hashtable_free_buckets (hashtable_t* hashtablePtr);
+
 
 /* =============================================================================
  * TMhashtable_free
@@ -216,6 +236,9 @@
 void
 TMhashtable_free (TM_ARGDECL  hashtable_t* hashtablePtr);
 
+void
+TMhashtable_free_buckets (TM_ARGDECL  hashtable_t* hashtablePtr);
+
 
 /* =============================================================================
  * hashtable_isEmpty
@@ -329,7 +352,7 @@
 #define TMHASHTABLE_GETSIZE(ht)           TMhashtable_getSize(TM_ARG  ht)
 #define TMHASHTABLE_FIND(ht, k)           TMhashtable_find(TM_ARG  ht, k)
 #define TMHASHTABLE_INSERT(ht, k, d)      TMhashtable_insert(TM_ARG  ht, k, d)
-#define TMHASHTABLE_REMOVE(ht)            TMhashtable_remove(TM_ARG  ht)
+#define TMHASHTABLE_REMOVE(ht, k)         TMhashtable_remove(TM_ARG  ht, k)
 
 
 #ifdef __cplusplus
diff -Naur -x .svn stamp-0.9.10/lib/hle_intel.c stamp-0.9.10_Distribute/lib/hle_intel.c
--- stamp-0.9.10/lib/hle_intel.c	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/hle_intel.c	2014-12-18 12:21:39.352692862 +0900
@@ -0,0 +1,100 @@
+/* Copyright (c) IBM Corp. 2014. */
+/* Code that uses Intel Hardware Lock Elision: derived from htm_ibm.c */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <immintrin.h>
+#include "hle_intel.h"
+#include "thread.h"
+
+#define NUM_ATOMIC_REGIONS 20
+
+int global_lock;
+static THREAD_KEY_T global_tls_key;
+typedef struct event_counters_struct {
+	unsigned long long event_tx_enter;
+	unsigned long long event_tx;
+} event_counters_t;
+typedef struct tls_struct {
+	event_counters_t event_counters[NUM_ATOMIC_REGIONS];
+} tls_t;
+static event_counters_t global_event_counters;
+static event_counters_t global_ctr_per_region[NUM_ATOMIC_REGIONS];
+static int global_evt_ctrs_lock = 0;
+
+void tm_startup_hle() {
+	__atomic_store_n(&global_lock,0,__ATOMIC_RELEASE);
+	THREAD_KEY_INIT(global_tls_key);
+	
+	memset(&global_event_counters,0,sizeof(global_event_counters));
+	memset(&global_ctr_per_region,0,sizeof(global_ctr_per_region));
+}
+
+static void print_stats_hle(event_counters_t *stats) {
+	fprintf(stderr, "#HTM_STATS %15llu           tx_enter\n", stats->event_tx_enter);
+	fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  tx\n", stats->event_tx, 100 * stats->event_tx / (double)stats->event_tx_enter);
+}
+
+void tm_shutdown_hle() {
+	int region;
+	for(region=0; region<NUM_ATOMIC_REGIONS; region++) {
+		global_event_counters.event_tx_enter+=global_ctr_per_region[region].event_tx_enter;
+		global_event_counters.event_tx+=global_ctr_per_region[region].event_tx;
+	}
+	print_stats_hle(&global_event_counters);
+	for(region=0; region<NUM_ATOMIC_REGIONS; region++) {
+		if(global_ctr_per_region[region].event_tx_enter) {
+			fprintf(stderr, "--- region %d ------------------------------\n", region);
+			print_stats_hle(&global_ctr_per_region[region]);
+		}
+	}
+}
+
+void tm_thread_enter_hle() {
+	tls_t *tls;
+	if(!(tls=malloc(sizeof(tls_t)))) {
+		perror("malloc tls");
+		exit(1);
+	}
+	memset(tls,0,sizeof(tls_t));
+	THREAD_KEY_SET(global_tls_key,tls);
+}
+
+void tm_thread_exit_hle() {
+	tls_t *tls;
+	tls=THREAD_KEY_GET(global_tls_key);
+	int region;
+	/* Lock Global counters */
+	while(__atomic_exchange_n(&global_evt_ctrs_lock,1,__ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))
+		_mm_pause();
+	for(region=0; region<NUM_ATOMIC_REGIONS; region++) {
+		global_ctr_per_region[region].event_tx_enter += tls->event_counters[region].event_tx_enter;
+		global_ctr_per_region[region].event_tx += tls->event_counters[region].event_tx;
+	}
+	/* unlock global counters */
+	__atomic_store_n(&global_evt_ctrs_lock,0,__ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);
+	free(tls);
+}
+
+void tbegin_hle(int region_id) {
+	tls_t *tls;
+	tls=THREAD_KEY_GET(global_tls_key);
+	tls->event_counters[region_id].event_tx_enter++;
+	while(__atomic_exchange_n(&global_lock,1,__ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))
+		_mm_pause();
+	if(!_xtest()) {
+		tls->event_counters[region_id].event_tx++;
+	}
+	return;
+}
+
+void tend_hle() {
+	__atomic_store_n(&global_lock,0,__ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);
+}
+
+void tabort_hle() {
+  asm volatile(".byte 0xc6; .byte 0xf8; .byte 0xff" :: );
+  /*__builtin_ia32_xabort(0xff);*/
+}
diff -Naur -x .svn stamp-0.9.10/lib/hle_intel.h stamp-0.9.10_Distribute/lib/hle_intel.h
--- stamp-0.9.10/lib/hle_intel.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/hle_intel.h	2014-12-18 12:21:43.566568089 +0900
@@ -0,0 +1,15 @@
+/* Copyright (c) IBM Corp. 2014. */
+#ifndef HLE_INTEL_H
+#define HLE_INTEL_H 1
+
+extern void tm_startup_hle();
+extern void tm_shutdown_hle();
+
+extern void tm_thread_enter_hle();
+extern void tm_thread_exit_hle();
+
+extern void tbegin_hle(int region_id);
+extern void tend_hle();
+extern void tabort_hle();
+
+#endif
diff -Naur -x .svn stamp-0.9.10/lib/htm_ia32_stat.h stamp-0.9.10_Distribute/lib/htm_ia32_stat.h
--- stamp-0.9.10/lib/htm_ia32_stat.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/htm_ia32_stat.h	2014-12-18 12:21:49.350786634 +0900
@@ -0,0 +1,8 @@
+/* Copyright (c) IBM Corp. 2014. */
+HTM_IA32_STAT(GLOBAL_LOCK_ACQUIRED)
+HTM_IA32_STAT(XABORT)
+HTM_IA32_STAT(TRANSIENT)
+HTM_IA32_STAT(MEMADDR_CONFLICT)
+HTM_IA32_STAT(BUFFER_OVERFLOW)
+HTM_IA32_STAT(HIT_DEBUG_BREAKPOINT)
+HTM_IA32_STAT(DURING_NESTED_TRANSACTION)
diff -Naur -x .svn stamp-0.9.10/lib/htm_ibm.c stamp-0.9.10_Distribute/lib/htm_ibm.c
--- stamp-0.9.10/lib/htm_ibm.c	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/htm_ibm.c	2014-12-18 12:21:54.329647772 +0900
@@ -0,0 +1,671 @@
+/* Copyright (c) IBM Corp. 2014. */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include "htm_ibm.h"
+#include "htm_util.h"
+#include "thread.h"
+#include "mfence.h"
+#include "tm.h"
+#ifdef __bgq__
+#include <speculation.h>
+#endif
+
+#define NUM_HTM_STATS_EVENTS 14
+#define NUM_HTM_ABORT_REASON_CODES 19
+#define NUM_HTM_TBEGIN_RETURNS 3
+#define NUM_ATOMIC_REGIONS 20
+#ifndef DETECT_DELINQUENTS
+#define DETECT_DELINQUENTS 0
+#endif
+
+enum {
+  event_tx = 0,
+  event_tx_enter,
+  event_abort,
+  event_first_abort,
+  event_global_lock_wait_before_tx_spin,
+  event_global_lock_wait_before_tx_sleep,
+  event_global_lock_wait_and_retry_spin,
+  event_global_lock_wait_and_retry_sleep,
+  event_global_lock_acquired,
+  event_persistent_abort_retry,
+  event_global_lock_persistent_abort,
+  event_transient_abort_retry,
+  event_global_lock_transient_abort,
+  event_detected_delinquent
+};
+
+typedef struct htm_stats_struct {
+  unsigned long long event_counter[NUM_HTM_STATS_EVENTS];
+#if defined(__370__)
+  unsigned long long abort_reason_code[NUM_HTM_ABORT_REASON_CODES][NUM_HTM_TBEGIN_RETURNS];
+#elif defined(__x86_64__)
+#define HTM_IA32_STAT(nam) long long unsigned int nam;
+  struct{
+#include "htm_ia32_stat.h"
+  } abort_reason_counters;
+#undef HTM_IA32_STAT
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define HTM_PPC_STAT(NAM) long long unsigned int NAM;
+  struct {
+#include "htm_ppc_stat.h"
+  } abort_reason_counters;
+#undef HTM_PPC_STAT
+#else
+  char dummy;
+#endif
+} htm_stats_t;
+
+typedef struct tls_struct {
+  htm_stats_t htm_stats[NUM_ATOMIC_REGIONS];
+} tls_t;
+
+/*#define USE_MUTEX*/
+
+static union {
+  char two_cache_lines[512];
+  struct {
+    char one_cache_line[256];
+    volatile int global_lock;
+    char another_cache_line[252];
+  } a;
+} gl;
+#ifdef USE_MUTEX
+static THREAD_MUTEX_T global_lock_mutex;
+static THREAD_COND_T global_lock_cond;
+#endif
+static THREAD_KEY_T global_tls_key;
+
+static int transient_retry_max = 16;
+static int persistent_retry_max = 1;
+static int global_lock_retry_max = 16;
+static int collect_stats = 0;
+static htm_stats_t global_htm_stats_per_region[NUM_ATOMIC_REGIONS];
+static htm_stats_t global_htm_stats;
+static THREAD_MUTEX_T global_htm_stats_lock;
+
+
+/*#define ABORTED_INSN_ADDRESS_STATS*/
+#ifdef ABORTED_INSN_ADDRESS_STATS
+#define ABORTED_INSN_ADDRESS_STATS_MAP_SIZE (15 * 1024 * 1024 / 2)
+#define ABORTED_INSN_ADDRESS_STATS_START_ADDRESS 0x13b08000
+/*#define ABORTED_INSN_ADDRESS_STATS_START_ADDRESS 0x25c08000*/
+uint64_t aborted_insn_address_stats[ABORTED_INSN_ADDRESS_STATS_MAP_SIZE];
+uint64_t aborted_insn_address_reason_code;
+#endif
+
+void
+tm_startup_ibm()
+{
+  const char *env_transient_retry_max;
+  const char *env_persistent_retry_max;
+  const char *env_global_lock_retry_max;
+  const char *env_collect_stats;
+#ifdef ABORTED_INSN_ADDRESS_STATS
+  const char *env_aborted_insn_address_reason_code;
+#endif
+
+  gl.a.global_lock = 0;
+#ifdef USE_MUTEX
+  THREAD_MUTEX_INIT(global_lock_mutex);
+  THREAD_COND_INIT(global_lock_cond);
+#endif
+  THREAD_KEY_INIT(global_tls_key);
+
+  env_transient_retry_max = getenv("HTM_TRETRY");
+  if (env_transient_retry_max) {
+#ifdef __bgq__
+    fprintf(stderr, "<HTM_TRETRY has no meaning on Blue Gene/Q>");
+#else
+    transient_retry_max = atoi(env_transient_retry_max);
+    fprintf(stderr, "<HTM_TRETRY=%d>\n", transient_retry_max);
+#endif
+  }
+
+  env_persistent_retry_max = getenv("HTM_PRETRY");
+  if (env_persistent_retry_max) {
+#ifdef __bgq__
+    fprintf(stderr, "<HTM_PRETRY has no meaning on Blue Gene/Q>");
+#else
+    persistent_retry_max = atoi(env_persistent_retry_max);
+    fprintf(stderr, "<HTM_PRETRY=%d>\n", persistent_retry_max);
+#endif
+  }
+
+  env_global_lock_retry_max = getenv("HTM_GRETRY");
+  if (env_global_lock_retry_max) {
+#ifdef __bgq__
+    fprintf(stderr, "<HTM_GRETRY has no meaning on Blue Gene/Q>");
+#else
+    global_lock_retry_max = atoi(env_global_lock_retry_max);
+    fprintf(stderr, "<HTM_GRETRY=%d>\n", global_lock_retry_max);
+#endif
+  }
+
+  env_collect_stats = getenv("HTM_STATS");
+  if (DETECT_DELINQUENTS || env_collect_stats) {
+    collect_stats = 1;
+  }
+
+#ifdef ABORTED_INSN_ADDRESS_STATS
+  env_aborted_insn_address_reason_code = getenv("HTM_AIACODE");
+  if (env_aborted_insn_address_reason_code) {
+    aborted_insn_address_reason_code = (uint64_t)atoi(env_aborted_insn_address_reason_code);
+  }
+#endif
+
+#ifndef __bgq__
+  if (collect_stats) {
+    memset(&global_htm_stats_per_region, 0, sizeof(global_htm_stats_per_region));
+    memset(&global_htm_stats, 0, sizeof(global_htm_stats));
+    THREAD_MUTEX_INIT(global_htm_stats_lock);
+  }
+#endif
+}
+
+static void
+print_stats(htm_stats_t *stats)
+{
+#if defined(__bgq__)
+  TmReport_t bgq_htm_stats;
+
+  tm_get_all_stats(&bgq_htm_stats);
+  printf("#HTM_STATS %15lu totalTransactions\n", bgq_htm_stats.totalTransactions);
+  printf("#HTM_STATS %15lu totalRollbacks\n", bgq_htm_stats.totalRollbacks);
+  printf("#HTM_STATS %15lu totalSerializedJMV\n", bgq_htm_stats.totalSerializedJMV);
+  printf("#HTM_STATS %15lu totalSerializedMAXRB\n", bgq_htm_stats.totalSerializedMAXRB);
+  printf("#HTM_STATS %15lu totalSerializedOTHER\n", bgq_htm_stats.totalSerializedOTHER);
+#else /* ! __bgq__ */
+#if defined(__370__)
+  int i;
+  const char *reason_string[] = {
+    "TDB_not_set",
+    "Restart_interruption",
+    "External_interruption",
+    NULL,
+    "Program_interruption",
+    "Machine-check_interruption",
+    "I/O_interruption",
+    "Fetch_overflow",
+    "Store_overflow",
+    "Fetch_conflict",
+    "Store_conflict",
+    "Restricted_instruction",
+    "Program-interruption_condition",
+    "Nesting_depth_exceeded",
+    "Cache_fetch-related",
+    "Cache_store-related",
+    "Cache_other",
+    "Undetermined_condition",
+    "TABORT_instruction"
+  };
+#endif
+
+  fprintf(stderr, "#HTM_STATS %15llu           tx_enter\n", stats->event_counter[event_tx_enter]);
+  fprintf(stderr, "#HTM_STATS %15llu           tx\n", stats->event_counter[event_tx]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_wait_before_tx_spin\n", stats->event_counter[event_global_lock_wait_before_tx_spin], 100 * stats->event_counter[event_global_lock_wait_before_tx_spin] / (double)stats->event_counter[event_tx_enter]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_wait_before_tx_sleep\n", stats->event_counter[event_global_lock_wait_before_tx_sleep], 100 * stats->event_counter[event_global_lock_wait_before_tx_sleep] / (double)stats->event_counter[event_tx_enter]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  abort\n", stats->event_counter[event_abort], 100 * stats->event_counter[event_abort] / (double)stats->event_counter[event_tx]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  first_abort\n", stats->event_counter[event_first_abort], 100 * stats->event_counter[event_first_abort] / (double)stats->event_counter[event_tx_enter]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_wait_and_retry_spin\n", stats->event_counter[event_global_lock_wait_and_retry_spin], 100 * stats->event_counter[event_global_lock_wait_and_retry_spin] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_wait_and_retry_sleep\n", stats->event_counter[event_global_lock_wait_and_retry_sleep], 100 * stats->event_counter[event_global_lock_wait_and_retry_sleep] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_acquired\n", stats->event_counter[event_global_lock_acquired], 100 * stats->event_counter[event_global_lock_acquired] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  persistent_abort_retry\n", stats->event_counter[event_persistent_abort_retry], 100 * stats->event_counter[event_persistent_abort_retry] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_persistent_abort\n", stats->event_counter[event_global_lock_persistent_abort], 100 * stats->event_counter[event_global_lock_persistent_abort] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  transient_abort_retry\n", stats->event_counter[event_transient_abort_retry], 100 * stats->event_counter[event_transient_abort_retry] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  global_lock_transient_abort\n", stats->event_counter[event_global_lock_transient_abort], 100 * stats->event_counter[event_global_lock_transient_abort] / (double)stats->event_counter[event_abort]);
+  fprintf(stderr, "#HTM_STATS %15llu %6.2f %%  detected_delinquent\n", stats->event_counter[event_detected_delinquent], 100 * stats->event_counter[event_detected_delinquent] / (double)stats->event_counter[event_tx_enter]);
+
+#if defined(__370__)
+  for (i = 0; i < NUM_HTM_ABORT_REASON_CODES; i++) {
+    if (reason_string[i]) {
+      unsigned long long total = stats->abort_reason_code[i][0] + stats->abort_reason_code[i][1] + stats->abort_reason_code[i][2];
+      fprintf(stderr, "#HTM_STATS %15llu %s\n", total, reason_string[i]);
+    }
+  }
+#elif defined(__x86_64__)
+#define HTM_IA32_STAT(nam) fprintf(stderr, "#HTM_STATS %15llu " #nam "\n", stats->abort_reason_counters.nam );
+#include "htm_ia32_stat.h"
+#undef HTM_IA32_STAT
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define HTM_PPC_STAT(nam) fprintf(stderr, "#HTM_STATS %15llu " #nam "\n", stats->abort_reason_counters.nam );
+#include "htm_ppc_stat.h"
+#undef HTM_PPC_STAT
+#endif
+#endif /* ! __bgq__ */
+}
+
+void
+tm_shutdown_ibm()
+{
+  if (collect_stats) {
+#ifndef __bgq__
+    int i;
+    int region;
+
+    for (region = 0; region < NUM_ATOMIC_REGIONS; region++) {
+      for (i = 0; i < NUM_HTM_STATS_EVENTS; i++) {
+	global_htm_stats.event_counter[i] += global_htm_stats_per_region[region].event_counter[i];
+      }
+#if defined(__370__)
+      for (i = 0; i < NUM_HTM_ABORT_REASON_CODES; i++) {
+	int j;
+	for (j = 0; j < NUM_HTM_TBEGIN_RETURNS; j++) {
+	  global_htm_stats.abort_reason_code[i][j] += global_htm_stats_per_region[region].abort_reason_code[i][j];
+	}
+      }
+#elif defined(__x86_64__)
+#define HTM_IA32_STAT(nam) global_htm_stats.abort_reason_counters.nam += global_htm_stats_per_region[region].abort_reason_counters.nam;
+#include "htm_ia32_stat.h"
+#undef HTM_IA32_STAT
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define HTM_PPC_STAT(nam) global_htm_stats.abort_reason_counters.nam += global_htm_stats_per_region[region].abort_reason_counters.nam;
+#include "htm_ppc_stat.h"
+#undef HTM_PPC_STAT
+#endif
+    }
+#endif /* ! __bgq__ */
+
+    print_stats(&global_htm_stats);
+    if (getenv("HTM_STATS_PER_REGION")) {
+#ifdef __bgq__
+      fprintf(stderr, "<HTM_STATS_PER_REGION is not supported on Blue Gene/Q>\n");
+#else
+      for (region = 0; region < NUM_ATOMIC_REGIONS; region++) {
+	if (global_htm_stats_per_region[region].event_counter[event_tx] != 0) {
+	  fprintf(stderr, "--- region %d ------------------------------\n", region);
+	  print_stats(&global_htm_stats_per_region[region]);
+	}
+      }
+#endif
+    }
+  }
+
+#ifdef ABORTED_INSN_ADDRESS_STATS
+  {
+    int insn_addr;
+    for (insn_addr = 0; insn_addr < ABORTED_INSN_ADDRESS_STATS_MAP_SIZE; insn_addr++) {
+      if (aborted_insn_address_stats[insn_addr] != 0) {
+	fprintf(stderr, "ABORTED_INSN_ADDRESS %" PRIx64 " %x %" PRIu64 "\n", (uint64_t)(ABORTED_INSN_ADDRESS_STATS_START_ADDRESS + insn_addr * 2), insn_addr * 2, aborted_insn_address_stats[insn_addr]);
+      }
+    }
+  }
+#endif
+
+  if (getenv("LOOP_AT_END")) {
+    for ( ; ; ) {
+      sleep(3600);
+    }
+  }
+}
+
+void
+tm_thread_enter_ibm()
+{
+#ifndef __bgq__
+  tls_t *tls;
+
+  tls = malloc(sizeof(tls_t));
+  if (tls == NULL) {
+    fprintf(stderr, "malloc error\n");
+    exit(1);
+  }
+  memset(tls, 0, sizeof(tls_t));
+
+  THREAD_KEY_SET(global_tls_key, tls);
+#endif /* ! __bgq__ */
+}
+
+void
+tm_thread_exit_ibm()
+{
+#ifndef __bgq__
+  if (collect_stats) {
+    tls_t *tls;
+    int i;
+    int region;
+
+    tls = THREAD_KEY_GET(global_tls_key);
+
+    THREAD_MUTEX_LOCK(global_htm_stats_lock);
+    for (region = 0; region < NUM_ATOMIC_REGIONS; region++) {
+      for (i = 0; i < NUM_HTM_STATS_EVENTS; i++) {
+	global_htm_stats_per_region[region].event_counter[i] += tls->htm_stats[region].event_counter[i];
+      }
+#if defined(__370__)
+      for (i = 0; i < NUM_HTM_ABORT_REASON_CODES; i++) {
+	int j;
+	for (j = 0; j < NUM_HTM_TBEGIN_RETURNS; j++) {
+	  global_htm_stats_per_region[region].abort_reason_code[i][j] += tls->htm_stats[region].abort_reason_code[i][j];
+	}
+      }
+#elif defined(__x86_64__)
+#define HTM_IA32_STAT(nam) global_htm_stats_per_region[region].abort_reason_counters.nam += tls->htm_stats[region].abort_reason_counters.nam;
+#include "htm_ia32_stat.h"
+#undef HTM_IA32_STAT
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define HTM_PPC_STAT(nam) global_htm_stats_per_region[region].abort_reason_counters.nam += tls->htm_stats[region].abort_reason_counters.nam;
+#include "htm_ppc_stat.h"
+#undef HTM_PPC_STAT
+#endif
+    }
+    THREAD_MUTEX_UNLOCK(global_htm_stats_lock);
+  }
+#endif /* ! __bgq__ */
+}
+
+static int
+fall_back_global_lock(int acquire)
+{
+#ifdef USE_MUTEX
+  const int spin_max = 2000000000;
+  int spin_count = spin_max;
+  while (gl.a.global_lock && --spin_count > 0)
+    ;
+  if (! acquire && ! gl.a.global_lock) {
+    return 0;
+  }
+
+  THREAD_MUTEX_LOCK(global_lock_mutex);
+  while (gl.a.global_lock) {
+    THREAD_COND_WAIT(global_lock_cond, global_lock_mutex);
+  }
+  gl.a.global_lock = 1;
+  THREAD_MUTEX_UNLOCK(global_lock_mutex);
+
+  return 1;
+#else /* !USE_MUTEX */
+#if defined(__370__)
+  cs_t local_value = 0;
+  cs_t new_value = 1;
+#endif
+
+  while (gl.a.global_lock)
+    ;
+  if (! acquire)
+    return 0;
+
+#if defined(__370__)
+  while (cs(&local_value, (cs_t *)&gl.a.global_lock, new_value)) {
+    while (local_value = gl.a.global_lock)
+      ;
+  }
+#elif defined(__IBMC__)
+  memory_fence();
+  while(__check_lock_mp(&gl.a.global_lock, 0, 1));
+  memory_fence();
+#elif defined(__GNUC__)
+  while (__sync_val_compare_and_swap(&gl.a.global_lock, 0, 1)) {
+    while (gl.a.global_lock)
+      ;
+  }
+#else
+#error
+#endif
+
+  return 1;
+#endif /* USE_MUTEX */
+}
+
+#define INCREMENT_STAT(field)				\
+  do {							\
+    if (collect_stats) {				\
+      tls->htm_stats[region_id].event_counter[event_ ## field]++;	\
+    }							\
+  } while (0)
+
+static int isAbortPersistent(int tbegin_result,TransactionDiagnosticInfo *diag) {
+#if defined(__370__)
+  uint64_t reason=diag->transactionAbortCode;
+  return (tbegin_result != 4 &&
+	  (diag->format != 1 || reason == 7 || reason == 8 || (11 <= reason && reason <= 13)));
+#elif defined(__x86_64__)
+  return ( (tbegin_result != 4) && !(diag->transactionAbortCode&XABORT_RETRY));
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+  return (tbegin_result != 4) && (diag->transactionAbortCode&0x0100000000000000ULL);
+#else
+  return 0;
+#endif
+}
+
+static int isTransactionDelinquent(htm_stats_t* stats) {
+  static const long long min_tx_before_detection=1000;
+  static const long long delinquent_abort_threshold=80;
+  long long abort_ratio;
+  int res=0;
+  if(min_tx_before_detection<(stats->event_counter[event_tx])) {
+    abort_ratio=(100LL* stats->event_counter[event_abort]) / stats->event_counter[event_tx];
+    if(abort_ratio>delinquent_abort_threshold) {
+      res=1;
+    }
+  }
+  return res;
+}
+
+/*#define ABORT_CC_AND_RETRY_STATS*/
+
+void
+tbegin_ibm(int region_id)
+{
+  int tbegin_result;
+  TransactionDiagnosticInfo diag;
+  int transient_retry_count;
+  int persistent_retry_count;
+  int global_lock_retry_count;
+  tls_t *tls = NULL;
+  int first_retry;
+#if defined(__370__)
+  uint64_t saved_fprs[8];  /* FPR8 - FPR15 */
+#endif
+#ifdef ABORT_CC_AND_RETRY_STATS
+  uint64_t saved_reason = 0; uint8_t saved_LSUAbortCode = 0; int saved_tbegin_result = 0;
+#endif
+
+  if (collect_stats) {
+    tls = THREAD_KEY_GET(global_tls_key);
+  }
+
+  INCREMENT_STAT(tx_enter);
+
+  /* Do not use HTM for delinquent transactions */
+  if(DETECT_DELINQUENTS && isTransactionDelinquent(&(tls->htm_stats[region_id]))) {
+    fall_back_global_lock(1);
+    INCREMENT_STAT(detected_delinquent);
+    return;
+  }
+
+  if (gl.a.global_lock) {
+    if (fall_back_global_lock(0)) {
+      INCREMENT_STAT(global_lock_wait_before_tx_sleep);
+      return;
+    }
+    INCREMENT_STAT(global_lock_wait_before_tx_spin);
+  }
+
+  transient_retry_count = transient_retry_max;
+  persistent_retry_count = persistent_retry_max;
+  global_lock_retry_count = global_lock_retry_max;
+  first_retry = 1;
+#if defined(__370__)
+  save_preserved_fpr(saved_fprs);
+#endif
+ tx_retry:
+  INCREMENT_STAT(tx);
+  tbegin_result = tbegin(&diag);
+  if (tbegin_result == 0) {
+    /* Transaction */
+    if (gl.a.global_lock) {
+      tend();
+      tbegin_result = 4;
+    }
+#ifdef HTM_CONSERVE_RWBUF
+    else {
+      suspend_tx();
+    }
+#endif
+  }
+  if (tbegin_result != 0) {
+    /* Abort */
+    uint64_t reason = diag.transactionAbortCode;
+    /*int saved_first_retry;*/
+
+    if (tbegin_result != 4) {
+#if defined(__370__)
+      restore_preserved_fpr(saved_fprs);
+#endif
+    }
+
+#ifdef ABORT_CC_AND_RETRY_STATS
+    if (global_lock_retry_count == global_lock_retry_max
+	&& reason == saved_reason && diag.LSUAbortCode == saved_LSUAbortCode && tbegin_result == saved_tbegin_result) {
+      printf("AbortCcAndRetryStats r %d %llu %u %d\n", transient_retry_count, saved_reason, saved_LSUAbortCode, saved_tbegin_result);
+    }
+#endif
+
+    INCREMENT_STAT(abort);
+    /*saved_first_retry = first_retry;*/
+    if (first_retry) {
+      first_retry = 0;
+      INCREMENT_STAT(first_abort);
+    }
+
+    if (gl.a.global_lock) {
+      if (--global_lock_retry_count > 0) {
+	if (fall_back_global_lock(0)) {
+	  INCREMENT_STAT(global_lock_wait_and_retry_sleep);
+	  return;
+	}
+	INCREMENT_STAT(global_lock_wait_and_retry_spin);
+	goto tx_retry;
+      }
+      INCREMENT_STAT(global_lock_acquired);
+      fall_back_global_lock(1);
+    } else {
+      if (collect_stats /*&& saved_first_retry*/) {
+#if defined(__370__)
+	if (tbegin_result == 4) {
+	  tls->htm_stats[region_id].abort_reason_code[18][1]++;
+	} else if (diag.format != 1) {
+	  tls->htm_stats[region_id].abort_reason_code[0][tbegin_result - 1]++;
+	} else if (reason <= 16) {
+	  tls->htm_stats[region_id].abort_reason_code[reason][tbegin_result - 1]++;
+	} else if (reason == 255) {
+	  tls->htm_stats[region_id].abort_reason_code[17][tbegin_result - 1]++;
+	} else {
+	  tls->htm_stats[region_id].abort_reason_code[18][tbegin_result - 1]++;
+	}
+#elif defined(__x86_64__)
+#define TLSCTR tls->htm_stats[region_id].abort_reason_counters
+	if(tbegin_result==4) {
+	  TLSCTR.GLOBAL_LOCK_ACQUIRED ++;
+	} else {
+	  TLSCTR.XABORT                    += (reason&XABORT_EXPLICIT)?1L:0L;
+	  TLSCTR.TRANSIENT                 += (reason&XABORT_RETRY)?1L:0L;
+	  TLSCTR.MEMADDR_CONFLICT          += (reason&XABORT_CONFLICT)?1L:0L;
+	  TLSCTR.BUFFER_OVERFLOW           += (reason&XABORT_CAPACITY)?1L:0L;
+	  TLSCTR.HIT_DEBUG_BREAKPOINT      += (reason&XABORT_DEBUG)?1L:0L;
+	  TLSCTR.DURING_NESTED_TRANSACTION += (reason&XABORT_NESTED)?1L:0L;
+	}
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define TLSCTR tls->htm_stats[region_id].abort_reason_counters
+#define PPC_BFIELD(x) ((0x1ULL)<<(63-x))
+	if(tbegin_result==4) {
+	  TLSCTR.Global_Lock_Acquired ++;
+	} else {
+	  TLSCTR.Failure_Persistent                += (reason&PPC_BFIELD( 7))?1:0;
+	  TLSCTR.Disallowed                        += (reason&PPC_BFIELD( 8))?1:0;
+	  TLSCTR.Nesting_Overflow                  += (reason&PPC_BFIELD( 9))?1:0;
+	  TLSCTR.Footprint_Overflow                += (reason&PPC_BFIELD(10))?1:0;
+	  TLSCTR.Self_Induced_Conflict             += (reason&PPC_BFIELD(11))?1:0;
+	  TLSCTR.Non_Transactional_Conflict        += (reason&PPC_BFIELD(12))?1:0;
+	  TLSCTR.Transaction_Conflict              += (reason&PPC_BFIELD(13))?1:0;
+	  TLSCTR.Translation_Invalidation_Conflict += (reason&PPC_BFIELD(14))?1:0;
+	  TLSCTR.Implementation_Specific           += (reason&PPC_BFIELD(15))?1:0;
+	  TLSCTR.Instruction_Fetch_Conflict        += (reason&PPC_BFIELD(16))?1:0;
+	}
+#endif
+      }
+
+#ifdef ABORTED_INSN_ADDRESS_STATS
+      if (reason == aborted_insn_address_reason_code) {
+	int idx;
+
+	if (diag.abortedTransactionInstructionAddress < ABORTED_INSN_ADDRESS_STATS_START_ADDRESS) {
+	  idx = 0;
+	} else {
+	  idx = (diag.abortedTransactionInstructionAddress - ABORTED_INSN_ADDRESS_STATS_START_ADDRESS) / 2;
+	  if (idx >= ABORTED_INSN_ADDRESS_STATS_MAP_SIZE)
+	    idx = ABORTED_INSN_ADDRESS_STATS_MAP_SIZE - 1;
+	}
+	aborted_insn_address_stats[idx]++;
+      }
+#endif
+
+#ifdef ABORT_CC_AND_RETRY_STATS
+      if (global_lock_retry_count == global_lock_retry_max
+	  && (transient_retry_count == transient_retry_max ||
+	      reason == saved_reason && diag.LSUAbortCode == saved_LSUAbortCode && tbegin_result == saved_tbegin_result)) {
+	printf("AbortCcAndRetryStats f %d %llu %u %d\n", transient_retry_count, reason, diag.LSUAbortCode, tbegin_result);
+	saved_reason = reason; saved_LSUAbortCode = diag.LSUAbortCode; saved_tbegin_result = tbegin_result;
+      } else {
+	saved_reason = 0; saved_LSUAbortCode = 0; saved_tbegin_result = 0;
+      }
+#else /* ABORT_CC_AND_RETRY_STATS */
+      if (isAbortPersistent(tbegin_result,&diag)) {
+	/* Persistent abort */
+	if (--persistent_retry_count > 0) {
+	  INCREMENT_STAT(persistent_abort_retry);
+	  goto tx_retry;
+	}
+	INCREMENT_STAT(global_lock_persistent_abort);
+	fall_back_global_lock(1);
+      } else
+#endif /* ! ABORT_CC_AND_RETRY_STATS */
+      {
+	/* Transient abort */
+	if (--transient_retry_count > 0) {
+	  INCREMENT_STAT(transient_abort_retry);
+	  goto tx_retry;
+	}
+	INCREMENT_STAT(global_lock_transient_abort);
+	fall_back_global_lock(1);
+      }
+    }
+  }
+}
+
+
+void
+tend_ibm()
+{
+#ifdef HTM_CONSERVE_RWBUF
+  resume_tx();
+#endif
+  if (gl.a.global_lock) {
+#ifdef USE_MUTEX
+    THREAD_MUTEX_LOCK(global_lock_mutex);
+    gl.a.global_lock = 0;
+    THREAD_COND_SIGNAL(global_lock_cond);
+    THREAD_MUTEX_UNLOCK(global_lock_mutex);
+#else
+    memory_fence();
+#if !defined(__370__) && defined(__IBMC__)
+    __clear_lock_mp(&gl.a.global_lock,0);
+#else
+    gl.a.global_lock = 0;
+#endif /* __IBMC__ */
+#endif
+    /*memory_fence();*/
+  } else {
+    tend();
+  }
+}
+
+void
+tabort_ibm()
+{
+  tabort(300);
+}
diff -Naur -x .svn stamp-0.9.10/lib/htm_ibm.h stamp-0.9.10_Distribute/lib/htm_ibm.h
--- stamp-0.9.10/lib/htm_ibm.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/htm_ibm.h	2014-12-18 12:21:57.928724071 +0900
@@ -0,0 +1,15 @@
+/* Copyright (c) IBM Corp. 2014. */
+#ifndef HTM_IBM_H
+#define HTM_IBM_H 1
+
+extern void tm_startup_ibm();
+extern void tm_shutdown_ibm();
+
+extern void tm_thread_enter_ibm();
+extern void tm_thread_exit_ibm();
+
+extern void tbegin_ibm(int region_id);
+extern void tend_ibm();
+extern void tabort_ibm();
+
+#endif
diff -Naur -x .svn stamp-0.9.10/lib/htm_ppc_stat.h stamp-0.9.10_Distribute/lib/htm_ppc_stat.h
--- stamp-0.9.10/lib/htm_ppc_stat.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/htm_ppc_stat.h	2014-12-18 12:22:03.080695529 +0900
@@ -0,0 +1,13 @@
+/* Copyright (c) IBM Corp. 2014. */
+HTM_PPC_STAT(Global_Lock_Acquired)
+/* See 5.4.2 */
+HTM_PPC_STAT(Failure_Persistent)
+HTM_PPC_STAT(Disallowed)
+HTM_PPC_STAT(Nesting_Overflow)
+HTM_PPC_STAT(Footprint_Overflow)
+HTM_PPC_STAT(Self_Induced_Conflict)
+HTM_PPC_STAT(Non_Transactional_Conflict)
+HTM_PPC_STAT(Transaction_Conflict)
+HTM_PPC_STAT(Translation_Invalidation_Conflict)
+HTM_PPC_STAT(Implementation_Specific)
+HTM_PPC_STAT(Instruction_Fetch_Conflict)
diff -Naur -x .svn stamp-0.9.10/lib/htm_util.c stamp-0.9.10_Distribute/lib/htm_util.c
--- stamp-0.9.10/lib/htm_util.c	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/htm_util.c	2014-12-18 12:22:09.493623112 +0900
@@ -0,0 +1,239 @@
+/* Copyright (c) IBM Corp. 2014. */
+#include <stdio.h>
+#include <stdint.h>
+#include <assert.h>
+#include "htm_util.h"
+
+#if defined(__370__)
+
+static int tbegin_impl(void *diag);
+#if 1
+/* lghi gpr3,0; tbegin 0(gpr1),FF00; brc 0x8,$+16; lghi gpr3,2; brc 0x6,$+8; lghi gpr3,3 */
+#pragma mc_func tbegin_impl {"A7390000" "E5601000FF00" "A7840008" "A7390002" "A7640004" "A7390003"}
+#else
+/* lghi gpr3,0; tbegin 0(gpr1),FF00; brc 0x8,$+24; lghi gpr3,1; brc 0x4,$+16; lghi gpr3,2; brc 0x2,$+8; lghi gpr3,3 */
+#pragma mc_func tbegin_impl {"A7390000" "E5601000FF00" "A784000C" "A7390001" "A7440008" "A7390002" "A7240004" "A7390003"}
+#endif
+
+static int tbegin_fp_impl(void *diag);
+#if 1
+#pragma mc_func tbegin_fp_impl {"A7390000" "E5601000FF04" "A7840008" "A7390002" "A7640004" "A7390003"}
+#else
+#pragma mc_func tbegin_fp_impl {"A7390000" "E5601000FF04" "A784000C" "A7390001" "A7440008" "A7390002" "A7240004" "A7390003"}
+#endif
+
+static void tend_impl(void *diag);
+#pragma mc_func tend_impl {"B2F81000"}  /* tend 0(gpr1) */
+
+static void ctend_impl(volatile int64_t *addr);
+#pragma mc_func ctend_impl {"E30010000028"}  /* ctend 0(gpr1) */
+
+static void tabort_impl(int code);
+#pragma mc_func tabort_impl {"B2FC1000"}  /* tabort 0(gpr1) */
+
+static void tabort_no_abend_in_no_tx_impl(int code);
+/* tbegin 0(gpr0),FF00; brc 0x7,$+8; tabort 0(gpr1) */
+#pragma mc_func tabort_no_abend_in_no_tx_impl {"E5600000FF00" "A7740004" "B2FC1000"}
+
+static void non_tx_store_impl(int64_t *addr, int64_t data);
+#pragma mc_func non_tx_store_impl { "E32010000025" }  /* ntstg gpr2,0(gpr1) */
+
+static uint64_t
+get_transaction_nesting_depth_impl();
+#pragma mc_func get_transaction_nesting_depth_impl { "B2EC0030" }  /* ETNDG gpr3 */
+
+/* std fpr8,0(gpr1); ...; std fpr15,56(gpr1) */
+static void save_preserved_fpr_impl(uint64_t *addr);
+#pragma mc_func save_preserved_fpr_impl {"60801000" "60901008" "60A01010" "60B01018" "60C01020" "60D01028" "60E01030" "60F01038"}
+
+/* ld fpr8,0(gpr1); ...; ld fpr15,56(gpr1) */
+static void restore_preserved_fpr_impl(uint64_t *addr);
+#pragma mc_func restore_preserved_fpr_impl {"68801000" "68901008" "68A01010" "68B01018" "68C01020" "68D01028" "68E01030" "68F01038"}
+
+int
+tbegin(TransactionDiagnosticInfo *diag)
+{
+  /*return tbegin_impl(diag);*/
+  return tbegin_fp_impl(diag);
+}
+
+#if defined(__370__) && __COMPILER_VER__ >= 0x410d0000
+/* Macro-expanded to intrinsic */
+#else
+void
+tend(void)
+{
+  TransactionDiagnosticInfo *diag = NULL;
+  tend_impl(diag);
+}
+#endif
+
+void
+ctend(volatile int64_t *addr)
+{
+  ctend_impl(addr);
+}
+
+void
+tabort(uint64_t code)
+{
+  tabort_impl(code);
+}
+
+void
+tabort_no_abend_in_no_tx(uint64_t code)
+{
+  tabort_no_abend_in_no_tx_impl(code);
+}
+
+#if defined(__370__) && __COMPILER_VER__ >= 0x410d0000
+/* Macro-expanded to intrinsic */
+#else
+void
+non_tx_store(int64_t *addr, int64_t data)
+{
+  /* addr must be 8-byte aligned */
+  non_tx_store_impl(addr, data);
+}
+#endif
+
+#if defined(__370__) && __COMPILER_VER__ >= 0x410d0000
+/* Macro-expanded to intrinsic */
+#else
+int
+get_transaction_nesting_depth(void)
+{
+  uint64_t ret;
+
+  ret = get_transaction_nesting_depth_impl();
+  return ret & 0xFFFF;
+}
+#endif
+
+void
+save_preserved_fpr(uint64_t *addr)
+{
+  save_preserved_fpr_impl(addr);
+}
+
+void
+restore_preserved_fpr(uint64_t *addr)
+{
+  restore_preserved_fpr_impl(addr);
+}
+
+#elif defined(__x86_64__)  /* __370__ */
+
+/* Everything is in htm_util.h */
+
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+
+/* Everything is in htm_util.h */
+
+#else /* __370__ , __x86_64, __PPC__ */
+
+#error
+
+#endif  /* __370__ -> __x86_64 -> __PPC__ */
+
+void
+countHTMFailures(TransactionDiagnosticInfo *diag, uint64_t *counters)
+{
+#if defined(__370__)
+  uint64_t abortCode = diag->transactionAbortCode;
+  if (diag->format != 1) {
+    counters[0]++;
+  } else if (abortCode <= 2) {
+    counters[abortCode]++;
+    /* No such abort code as 3  */
+  } else if (abortCode <= 17) {
+    counters[abortCode - 1]++;
+  } else if (abortCode == 255) {
+    counters[17]++;
+  } else {
+    counters[18]++;
+  }
+#elif defined(__x86_64__)
+  uint64_t abortCode = diag->transactionAbortCode;
+  counters[0] += (abortCode & XABORT_EXPLICIT) ? 1 : 0;
+  counters[1] += (abortCode & XABORT_RETRY) ? 1 : 0;
+  counters[2] += (abortCode & XABORT_CONFLICT) ? 1 : 0;
+  counters[3] += (abortCode & XABORT_CAPACITY) ? 1 : 0;
+  counters[4] += (abortCode & XABORT_DEBUG) ? 1 : 0;
+  counters[5] += (abortCode & XABORT_NESTED) ? 1 : 0;
+  counters[6] += (abortCode & (XABORT_EXPLICIT | XABORT_RETRY | XABORT_CONFLICT | XABORT_CONFLICT | XABORT_DEBUG | XABORT_NESTED)) ? 0 : 1;  /* Other */
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+  uint64_t texasr = diag->transactionAbortCode;
+#define PPC_BFIELD(x) ((0x1ULL)<<(63-x))
+  counters[ 0] += (texasr & PPC_BFIELD( 7))? 1 : 0;
+  counters[ 1] += (texasr & PPC_BFIELD( 8))? 1 : 0;
+  counters[ 2] += (texasr & PPC_BFIELD( 9))? 1 : 0;
+  counters[ 3] += (texasr & PPC_BFIELD(10))? 1 : 0;
+  counters[ 4] += (texasr & PPC_BFIELD(11))? 1 : 0;
+  counters[ 5] += (texasr & PPC_BFIELD(12))? 1 : 0;
+  counters[ 6] += (texasr & PPC_BFIELD(13))? 1 : 0;
+  counters[ 7] += (texasr & PPC_BFIELD(14))? 1 : 0;
+  counters[ 8] += (texasr & PPC_BFIELD(15))? 1 : 0;
+  counters[ 9] += (texasr & PPC_BFIELD(16))? 1 : 0;
+  counters[10] += (texasr & PPC_BFIELD(31))? 1 : 0;
+  counters[11] += (texasr & (PPC_BFIELD(7) | PPC_BFIELD(8) | PPC_BFIELD(9) | PPC_BFIELD(10) | PPC_BFIELD(11) | PPC_BFIELD(12) | PPC_BFIELD(13) | PPC_BFIELD(14) | PPC_BFIELD(15) | PPC_BFIELD(16) | PPC_BFIELD(31))) ? 0 : 1;  /* Other */
+#else
+#error
+#endif
+}
+
+const char *
+getHTMFailureName(int id)
+{
+  const char *reason_strings[] = {
+#if defined(__370__)
+    "TDB_not_set",
+    "Restart_interruption",
+    "External_interruption",
+    "Program_interruption",
+    "Machine-check_interruption",
+    "I/O_interruption",
+    "Fetch_overflow",
+    "Store_overflow",
+    "Fetch_conflict",
+    "Store_conflict",
+    "Restricted_instruction",
+    "Program-interruption_condition",
+    "Nesting_depth_exceeded",
+    "Cache_fetch-related",
+    "Cache_store-related",
+    "Cache_other",
+    "CTEND_abort",
+    "Miscellaneous_condition",
+    "TABORT_instruction"
+#elif defined(__x86_64__)
+    "XABORT",
+    "TRANSIENT",
+    "MEMADDR_CONFLICT",
+    "BUFFER_OVERFLOW",
+    "HIT_DEBUG_BREAKPOINT",
+    "DURING_NESTED_TRANSACTION",
+    "OTHER"
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+    "Failure_Persistent",
+    "Disallowed",
+    "Nesting_Overflow",
+    "Footprint_Overflow",
+    "Self_Induced_Conflict",
+    "Non_Tx_Conflict",
+    "Tx_Conflict",
+    "Translation_Invalidation",
+    "Implementation_Specific",
+    "Instruction_Fetch_Conflict",
+    "Tabort_Treclaim",
+    "Other"
+#else
+#error
+#endif
+  };
+
+  if (id < 0 || NUM_HTM_FAILURE_REASONS <= id) {
+    return NULL;
+  }
+  return reason_strings[id];
+}
diff -Naur -x .svn stamp-0.9.10/lib/htm_util.h stamp-0.9.10_Distribute/lib/htm_util.h
--- stamp-0.9.10/lib/htm_util.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/htm_util.h	2014-12-18 12:22:12.521692905 +0900
@@ -0,0 +1,193 @@
+/* Copyright (c) IBM Corp. 2014. */
+#ifndef _HTM_UTIL_H
+#define _HTM_UTIL_H
+
+#include <stdint.h>
+#if defined(__370__) && __COMPILER_VER__ >= 0x410d0000
+#include <builtins.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+#if defined(__370__)
+  uint8_t format;
+  uint8_t flags;
+  uint16_t reserved0;
+  uint16_t reserved1;
+  uint16_t transactionNestingDepth;
+  uint64_t transactionAbortCode;
+  uint64_t conflictToken;
+  uint64_t abortedTransactionInstructionAddress;
+  uint8_t EAID;
+  uint8_t DXC;
+  uint16_t reserved2;
+  uint32_t programInterruptionIdentification;
+  uint64_t translationExceptionIdentification;
+  uint64_t breakingEventAddress;
+  uint64_t reserved3[8];
+  uint32_t reserved4;
+  uint16_t reserved5;
+  uint8_t reserved6;
+  uint8_t LSUAbortCode;
+  uint64_t generalRegisters[16];
+#elif defined(__x86_64)
+  uint64_t transactionAbortCode;
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+  uint64_t transactionAbortCode;
+  uint64_t abortedTransactionInstructionAddress;
+#endif
+} TransactionDiagnosticInfo;
+
+/*
+  int tbegin(TransactionDiagnosticInfo *diag);
+  Returns 0 for success
+          1 for inderminate
+          2 for transient abort
+	  3 for persistent abort
+ */
+
+#if defined(__370__)
+
+int tbegin(TransactionDiagnosticInfo *diag);
+#if __COMPILER_VER__ >= 0x410d0000
+#define tend() __TM_end()
+#else
+void tend();
+#endif
+void ctend(volatile int64_t *addr);
+void tabort(uint64_t code);
+void tabort_no_abend_in_no_tx(uint64_t code);
+#if __COMPILER_VER__ >= 0x410d0000
+/* addr must be 8-byte aligned */
+#define non_tx_store(addr, data) __TM_non_transactional_store((addr), (long long)data)
+#else
+void non_tx_store(int64_t *addr, int64_t data);
+#endif
+#if __COMPILER_VER__ >= 0x410d0000
+#define get_transaction_nesting_depth() __TM_nesting_depth(NULL)
+#else
+int get_transaction_nesting_depth();
+#endif
+void save_preserved_fpr(uint64_t *addr);
+void restore_preserved_fpr(uint64_t *addr);
+
+#define NUM_HTM_FAILURE_REASONS 19
+
+#elif defined(__x86_64)
+
+#define XABORT_EXPLICIT	0x01
+#define XABORT_RETRY	0x02
+#define XABORT_CONFLICT	0x04
+#define XABORT_CAPACITY	0x08
+#define XABORT_DEBUG	0x10
+#define XABORT_NESTED	0x20
+
+static inline int tbegin(TransactionDiagnosticInfo *diag)
+{
+  int xbegin_result;
+
+  xbegin_result = 0xffffffff;
+  asm volatile("mov %0, %%eax;"
+	       ".byte 0xc7; .byte 0xf8; .int 0x00000000;" /* xbegin */
+	       "mov %%eax, %0"
+	       : "+r"(xbegin_result)
+	       :
+	       : "%eax");
+  if (xbegin_result == 0xffffffff)
+    return 0;
+  else {
+    diag->transactionAbortCode = xbegin_result;
+    if (xbegin_result & XABORT_RETRY)
+      return 2;
+    return 3;
+  }
+}
+
+#define tend() do {							\
+    asm volatile(".byte 0x0f; .byte 0x01; .byte 0xd5" :: ); /* xend */	\
+  } while (0)
+
+#define tabort(code) do {						\
+    asm volatile(".byte 0xc6; .byte 0xf8; .byte 0xff" :: ); /* xabort */ \
+  } while (0)
+
+#define NUM_HTM_FAILURE_REASONS 7
+
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+
+static inline int tbegin(TransactionDiagnosticInfo *diag)
+{
+  uint32_t tbegin_status;
+
+  asm volatile(".long 0x7c00051d;"
+	       "mfcr %0"
+	       :"=r"(tbegin_status): : "cr0");	// tbegin. 0
+  if (! (tbegin_status & 0x20000000U))
+    return 0;
+  else {
+#ifdef _ARCH_PPC64
+    uint64_t texasr;
+    uint64_t tfiar;
+
+    asm volatile("mfspr %0,130;"
+		 "mfspr %1,129"
+		 :"=r"(texasr), "=r"(tfiar): );
+    diag->transactionAbortCode = texasr;
+#else
+    uint32_t texasr;
+    uint32_t texasru;
+    uint32_t tfiar;
+
+    asm volatile("mfspr %0,130;"
+		 "mfspr %1,131;"
+		 "mfspr %2,129"
+		 :"=r"(texasr), "=r"(texasru), "=r"(tfiar): );
+    diag->transactionAbortCode = (uint64_t)texasru << 32 | (uint64_t)texasr;
+#endif
+    diag->abortedTransactionInstructionAddress = (uint64_t)tfiar & ~0x3ULL;
+    if (texasr & 0x0100000000000000ULL)
+      return 3;
+    return 2;
+  }
+}
+
+/* tend. 0 */
+#define tend() do {				\
+    asm volatile(".long 0x7c00055d":::"cr0" );	\
+  } while (0)
+
+static inline void tabort(uint64_t code)
+{
+  uint64_t int_code = code << 56;
+  asm volatile("mr 3,%0;"
+	       ".long 0x7c03071d": : "r" (int_code) : "r3", "cr0"); // tabort. 3
+  //asm(".long 0x7c00071d":::"cr0" ); // tabort. 0
+}
+
+#define tsuspend() do {				\
+    asm volatile (".long 0x7C0005DD");		\
+  } while (0)
+
+#define tresume() do {				\
+    asm volatile (".long 0x7C2005DD");		\
+  } while (0)
+
+#define NUM_HTM_FAILURE_REASONS 12
+
+#else
+
+#error
+
+#endif
+
+void countHTMFailures(TransactionDiagnosticInfo *diag, uint64_t *counters);
+const char *getHTMFailureName(int id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HTM_UTIL_H */
diff -Naur -x .svn stamp-0.9.10/lib/map.h stamp-0.9.10_Distribute/lib/map.h
--- stamp-0.9.10/lib/map.h	2008-09-09 07:42:40.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/map.h	2014-12-18 12:22:19.447592848 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef MAP_H
@@ -91,6 +92,26 @@
 #  define MAP_INSERT(map, key, data)  hashtable_insert(map, (void*)(key), (void*)(data))
 #  define MAP_REMOVE(map, key)        hashtable_remove(map, (void*)(key))
 
+#elif defined(MAP_USE_CONCUREENT_HASHTABLE)
+
+#  include "conc_hashtable.h"
+
+#  define MAP_T                       conc_hashtable_t
+#  define MAP_ALLOC(hash, cmp)        conc_hashtable_alloc(1, hash, cmp, 2, 2)
+#  define MAP_FREE(map)               conc_hashtable_free(map)
+#  define MAP_CONTAINS(map, key)      conc_hashtable_containsKey(map, (void*)(key))
+#  define MAP_FIND(map, key)          conc_hashtable_find(map, (void*)(key))
+#  define MAP_INSERT(map, key, data)  conc_hashtable_insert(map, (void*)(key), (void*)(data))
+#  define MAP_REMOVE(map, key)        conc_hashtable_remove(map, (void*)(key))
+
+#  define TMMAP_ALLOC(hash, cmp)      TMCONC_HASHTABLE_ALLOC(1, hash, cmp, 2, 2)
+#  define TMMAP_FREE(map)             TMCONC_HASHTABLE_FREE(map)
+#  define TMMAP_CONTAINS(map, key)    TMCONC_HASHTABLE_CONTAINSKEY(map, (void*)(key))
+#  define TMMAP_FIND(map, key)        TMCONC_HASHTABLE_FIND(map, (void*)(key))
+#  define TMMAP_INSERT(map, key, data) \
+    TMCONC_HASHTABLE_INSERT(map, (void*)(key), (void*)(data))
+#  define TMMAP_REMOVE(map, key)      TMCONC_HASHTABLE_REMOVE(map, (void*)(key))
+
 #elif defined(MAP_USE_ATREE)
 
 #  include "atree.h"
@@ -236,6 +257,10 @@
     rbtree_insert(map, (void*)(key), (void*)(data))
 #  define MAP_REMOVE(map, key)        rbtree_delete(map, (void*)(key))
 
+/* Added by Odaira begin */
+#  define TMMAP_ALLOC(hash, cmp)        TMRBTREE_ALLOC(cmp)
+#  define TMMAP_FREE(map)               TMRBTREE_FREE(map)
+/* Added by Odaira end */
 #  define TMMAP_CONTAINS(map, key)    TMRBTREE_CONTAINS(map, (void*)(key))
 #  define TMMAP_FIND(map, key)        TMRBTREE_GET(map, (void*)(key))
 #  define TMMAP_INSERT(map, key, data) \
diff -Naur -x .svn stamp-0.9.10/lib/memory.c stamp-0.9.10_Distribute/lib/memory.c
--- stamp-0.9.10/lib/memory.c	2008-09-09 07:42:40.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/memory.c	2014-12-18 12:22:26.524574097 +0900
@@ -68,10 +68,12 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include "memory.h"
 #include "types.h"
 
@@ -84,14 +86,24 @@
 #endif
 
 
+#ifdef __370__
+#define PADDING_SIZE 32
+#elif defined(__bgq__)
+#define PADDING_SIZE 16
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define PADDING_SIZE 16
+#elif defined(__x86_64__)
 #define PADDING_SIZE 8
+#else
+#define PADDING_SIZE 8
+#endif
 typedef struct block {
-    long padding1[PADDING_SIZE];
+    uint64_t padding1[PADDING_SIZE];
     size_t size;
     size_t capacity;
     char* contents;
     struct block* nextPtr;
-    long padding2[PADDING_SIZE];
+    uint64_t padding2[PADDING_SIZE];
 } block_t;
 
 typedef struct pool {
diff -Naur -x .svn stamp-0.9.10/lib/mfence.h stamp-0.9.10_Distribute/lib/mfence.h
--- stamp-0.9.10/lib/mfence.h	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/mfence.h	2014-12-18 12:22:31.301574036 +0900
@@ -0,0 +1,22 @@
+/* Copyright (c) IBM Corp. 2014. */
+
+#if defined(__x86_64__)
+#include <emmintrin.h>
+#endif
+/* requires C99 */
+static inline void memory_fence(void) {
+#if defined(__370__)
+    /* Nothing to do */
+#elif defined(__PPC__) && defined(__IBMC__)
+  __lwsync();
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+    asm volatile("lwsync" : : );
+#elif defined(__x86_64__)
+  _mm_sfence();
+#elif defined(__GNUC__) || defined(__IBMC__)
+    __sync_synchronize();
+#else
+#error
+#endif
+}
+
diff -Naur -x .svn stamp-0.9.10/lib/rbtree.c stamp-0.9.10_Distribute/lib/rbtree.c
--- stamp-0.9.10/lib/rbtree.c	2008-09-09 07:42:41.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/rbtree.c	2014-12-18 12:22:41.654707508 +0900
@@ -78,6 +78,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <string.h>
@@ -102,6 +103,9 @@
 struct rbtree {
     node_t* root;
     long (*compare)(const void*, const void*);   /* returns {-1,0,1}, 0 -> equal */
+#ifdef RBTREE_SIZE_FIELD
+    long size;
+#endif
 };
 
 #define LDA(a)              *(a)
@@ -1276,6 +1280,9 @@
     if (n) {
         n->compare = (compare ? compare : &compareKeysDefault);
         n->root = NULL;
+#ifdef RBTREE_SIZE_FIELD
+	n->size = 0;
+#endif
     }
     return n;
 }
@@ -1292,6 +1299,9 @@
     if (n){
         n->compare = (compare ? compare : &compareKeysDefault);
         n->root = NULL;
+#ifdef RBTREE_SIZE_FIELD
+	n->size = 0;
+#endif
     }
     return n;
 }
@@ -1412,6 +1422,11 @@
     if (ex != NULL) {
         releaseNode(node);
     }
+#ifdef RBTREE_SIZE_FIELD
+    if (ex == NULL) {
+	STF(r, size, LDF(r, size) + 1);
+    }
+#endif
     return ((ex == NULL) ? TRUE : FALSE);
 }
 
@@ -1429,6 +1444,11 @@
     if (ex != NULL) {
         TMreleaseNode(TM_ARG  node);
     }
+#ifdef RBTREE_SIZE_FIELD
+    if (ex == NULL) {
+	TX_STF(r, size, TX_LDF(r, size) + 1);
+    }
+#endif
     return ((ex == NULL) ? TRUE : FALSE);
 }
 
@@ -1448,6 +1468,9 @@
     }
     if (node != NULL) {
         releaseNode(node);
+#ifdef RBTREE_SIZE_FIELD
+	STF(r, size, LDF(r, size) - 1);
+#endif
     }
     return ((node != NULL) ? TRUE : FALSE);
 }
@@ -1468,6 +1491,9 @@
     }
     if (node != NULL) {
         TMreleaseNode(TM_ARG  node);
+#ifdef RBTREE_SIZE_FIELD
+	TX_STF(r, size, TX_LDF(r, size) - 1);
+#endif
     }
     return ((node != NULL) ? TRUE : FALSE);
 }
@@ -1565,6 +1591,189 @@
 }
 
 
+/* =============================================================================
+ * rbtree_get_root_key
+ * =============================================================================
+ */
+void *
+rbtree_get_root_key (rbtree_t *r)
+{
+    node_t* t = LDNODE(r, root);
+    return LDF(t, k);
+}
+
+
+/* =============================================================================
+ * TMrbtree_get_root_key
+ * =============================================================================
+ */
+TM_CALLABLE
+void *
+TMrbtree_get_root_key (TM_ARGDECL  rbtree_t* r)
+{
+    node_t* t = TX_LDNODE(r, root);
+    return TX_LDF_P(t, k);
+}
+
+
+#ifdef RBTREE_SIZE_FIELD
+/* =============================================================================
+ * rbtree_get_size
+ * =============================================================================
+ */
+long
+rbtree_get_size (rbtree_t *r)
+{
+    return LDF(r, size);
+}
+
+
+/* =============================================================================
+ * TMrbtree_get_root_key
+ * =============================================================================
+ */
+TM_CALLABLE
+long
+TMrbtree_get_size (TM_ARGDECL  rbtree_t* r)
+{
+    return TX_LDF(r, size);
+}
+#endif
+
+
+/* =============================================================================
+ * rbtree_iter_reset
+ * =============================================================================
+ */
+void
+rbtree_iter_reset (rbtree_iter_t* itPtr, rbtree_t* r)
+{
+    *itPtr = NULL;
+}
+
+
+/* =============================================================================
+ * TMrbtree_iter_reset
+ * =============================================================================
+ */
+TM_CALLABLE
+void
+TMrbtree_iter_reset (TM_ARGDECL  rbtree_iter_t* itPtr, rbtree_t* r)
+{
+    TM_LOCAL_WRITE_P(*itPtr, NULL);
+}
+
+
+/* =============================================================================
+ * rbtree_iter_hasNext
+ * =============================================================================
+ */
+bool_t
+rbtree_iter_hasNext (rbtree_iter_t* itPtr, rbtree_t* s)
+{
+    node_t* r;
+    if (*itPtr == NULL) {
+	*itPtr = LDNODE(s, root);
+	if (*itPtr == NULL) {
+	    return FALSE;
+	}
+	r = *itPtr;
+    } else {
+	r = LDNODE(*itPtr, r);
+    }
+    if (r == NULL) {
+	node_t* n;
+	n = *itPtr;
+	while (LDNODE(n, p) != NULL && LDNODE(LDNODE(n, p), r) == n) {
+	    n = LDNODE(n, p);
+	}
+	if (LDNODE(n, p) == NULL) {
+	    return FALSE;
+	} else {
+	    *itPtr = LDNODE(n, p);
+	    return TRUE;
+	}
+    } else {
+	while (LDNODE(r, l) != NULL) {
+	    r = LDNODE(r, l);
+	}
+	*itPtr = r;
+	return TRUE;
+    }
+}
+
+
+/* =============================================================================
+ * TMrbtree_iter_hasNext
+ * =============================================================================
+ */
+TM_CALLABLE
+bool_t
+TMrbtree_iter_hasNext (TM_ARGDECL  rbtree_iter_t* itPtr, rbtree_t* s)
+{
+    node_t* r;
+    if (*itPtr == NULL) {
+	TM_LOCAL_WRITE_P(*itPtr, TX_LDNODE(s, root));
+	if (*itPtr == NULL) {
+	    return FALSE;
+	}
+	r = *itPtr;
+    } else {
+	r = TX_LDNODE(*itPtr, r);
+    }
+    if (r == NULL) {
+	node_t* n;
+	n = *itPtr;
+	while (TX_LDNODE(n, p) != NULL && TX_LDNODE(TX_LDNODE(n, p), r) == n) {
+	    n = TX_LDNODE(n, p);
+	}
+	if (TX_LDNODE(n, p) == NULL) {
+	    return FALSE;
+	} else {
+	    TM_LOCAL_WRITE_P(*itPtr, TX_LDNODE(n, p));
+	    return TRUE;
+	}
+    } else {
+	while (TX_LDNODE(r, l) != NULL) {
+	    r = TX_LDNODE(r, l);
+	}
+	TM_LOCAL_WRITE_P(*itPtr, r);
+	return TRUE;
+    }
+}
+
+
+/* =============================================================================
+ * rbtree_iter_next
+ * =============================================================================
+ */
+void*
+rbtree_iter_next (rbtree_iter_t* itPtr, rbtree_t* r)
+{
+    if (*itPtr == NULL) {
+	return NULL;
+    } else {
+	return LDF(*itPtr, v);
+    }
+}
+
+
+/* =============================================================================
+ * TMrbtree_iter_next
+ * =============================================================================
+ */
+TM_CALLABLE
+void*
+TMrbtree_iter_next (TM_ARGDECL  rbtree_iter_t* itPtr, rbtree_t* r)
+{
+    if (*itPtr == NULL) {
+	return NULL;
+    } else {
+	return TX_LDF_P(*itPtr, v);
+    }
+}
+
+
 /* /////////////////////////////////////////////////////////////////////////////
  * TEST_RBTREE
  * /////////////////////////////////////////////////////////////////////////////
diff -Naur -x .svn stamp-0.9.10/lib/rbtree.h stamp-0.9.10_Distribute/lib/rbtree.h
--- stamp-0.9.10/lib/rbtree.h	2008-09-09 07:42:41.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/rbtree.h	2014-12-18 12:22:48.490756659 +0900
@@ -78,6 +78,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef RBTREE_H
@@ -94,6 +95,7 @@
 
 
 typedef struct rbtree rbtree_t;
+typedef struct node* rbtree_iter_t;
 
 
 /* =============================================================================
@@ -225,13 +227,112 @@
 TMrbtree_contains (TM_ARGDECL  rbtree_t* r, void* key);
 
 
-#define TMRBTREE_ALLOC()          TMrbtree_alloc(TM_ARG_ALONE)
+/* =============================================================================
+ * rbtree_get_root_key
+ * =============================================================================
+ */
+void*
+rbtree_get_root_key (rbtree_t* r);
+
+
+/* =============================================================================
+ * TMrbtree_get_root_key
+ * =============================================================================
+ */
+TM_CALLABLE
+void*
+TMrbtree_get_root_key (TM_ARGDECL  rbtree_t* r);
+
+
+#ifdef RBTREE_SIZE_FIELD
+/* =============================================================================
+ * rbtree_get_size
+ * =============================================================================
+ */
+long
+rbtree_get_size (rbtree_t* r);
+
+
+/* =============================================================================
+ * TMrbtree_get_root_key
+ * =============================================================================
+ */
+TM_CALLABLE
+long
+TMrbtree_get_size (TM_ARGDECL  rbtree_t* r);
+#endif
+
+
+/* Fixed by Odaira begin */ 
+#define TMRBTREE_ALLOC(r)          TMrbtree_alloc(TM_ARG  r)
+/*#define TMRBTREE_ALLOC()          TMrbtree_alloc(TM_ARG_ALONE)*/
+/* Fixed by Odaira end */ 
 #define TMRBTREE_FREE(r)          TMrbtree_free(TM_ARG  r)
 #define TMRBTREE_INSERT(r, k, v)  TMrbtree_insert(TM_ARG  r, (void*)(k), (void*)(v))
 #define TMRBTREE_DELETE(r, k)     TMrbtree_delete(TM_ARG  r, (void*)(k))
 #define TMRBTREE_UPDATE(r, k, v)  TMrbtree_update(TM_ARG  r, (void*)(k), (void*)(v))
 #define TMRBTREE_GET(r, k)        TMrbtree_get(TM_ARG  r, (void*)(k))
 #define TMRBTREE_CONTAINS(r, k)   TMrbtree_contains(TM_ARG  r, (void*)(k))
+#define TMRBTREE_GET_ROOT_KEY(r)  TMrbtree_get_root_key(TM_ARG  r)
+#ifdef RBTREE_SIZE_FIELD
+#define TMRBTREE_GET_SIZE(r)      TMrbtree_get_size(TM_ARG  r)
+#endif
+
+
+/* =============================================================================
+ * rbtree_iter_reset
+ * =============================================================================
+ */
+void
+rbtree_iter_reset (rbtree_iter_t* itPtr, rbtree_t* r);
+
+
+/* =============================================================================
+ * TMrbtree_iter_reset
+ * =============================================================================
+ */
+TM_CALLABLE
+void
+TMrbtree_iter_reset (TM_ARGDECL  rbtree_iter_t* itPtr, rbtree_t* r);
+
+
+/* =============================================================================
+ * rbtree_iter_hasNext
+ * =============================================================================
+ */
+bool_t
+rbtree_iter_hasNext (rbtree_iter_t* itPtr, rbtree_t* r);
+
+
+/* =============================================================================
+ * TMrbtree_iter_hasNext
+ * =============================================================================
+ */
+TM_CALLABLE
+bool_t
+TMrbtree_iter_hasNext (TM_ARGDECL  rbtree_iter_t* itPtr, rbtree_t* r);
+
+
+/* =============================================================================
+ * rbtree_iter_next
+ * =============================================================================
+ */
+void*
+rbtree_iter_next (rbtree_iter_t* itPtr, rbtree_t* r);
+
+
+/* =============================================================================
+ * TMrbtree_iter_next
+ * =============================================================================
+ */
+TM_CALLABLE
+void*
+TMrbtree_iter_next (TM_ARGDECL  rbtree_iter_t* itPtr, rbtree_t* r);
+
+
+#define TMRBTREE_ITER_RESET(it, r)      TMrbtree_iter_reset(TM_ARG  it, r)
+#define TMRBTREE_ITER_HASNEXT(it, r)    TMrbtree_iter_hasNext(TM_ARG  it, r)
+#define TMRBTREE_ITER_NEXT(it, r)       TMrbtree_iter_next(TM_ARG  it, r)
 
 
 #ifdef __cplusplus
diff -Naur -x .svn stamp-0.9.10/lib/thread.c stamp-0.9.10_Distribute/lib/thread.c
--- stamp-0.9.10/lib/thread.c	2008-09-09 07:42:41.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/thread.c	2014-12-18 12:22:53.988581669 +0900
@@ -67,14 +67,16 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
+#include <stdio.h>
 #include <assert.h>
 #include <stdlib.h>
 #include "thread.h"
 #include "types.h"
 
-static THREAD_LOCAL_T    global_threadId;
+static THREAD_KEY_T    global_threadId;
 static long              global_numThread       = 1;
 static THREAD_BARRIER_T* global_barrierPtr      = NULL;
 static long*             global_threadIds       = NULL;
@@ -83,6 +85,13 @@
 static void            (*global_funcPtr)(void*) = NULL;
 static void*             global_argPtr          = NULL;
 static volatile bool_t   global_doShutdown      = FALSE;
+#ifdef GLOBAL_LOCK
+#ifdef USE_MUTEX
+THREAD_MUTEX_T global_lock;
+#else
+volatile int global_lock;
+#endif
+#endif
 
 
 /* =============================================================================
@@ -95,7 +104,7 @@
 {
     long threadId = *(long*)argPtr;
 
-    THREAD_LOCAL_SET(global_threadId, (long)threadId);
+    THREAD_KEY_SET(global_threadId, (long)threadId);
 
     while (1) {
         THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
@@ -125,6 +134,12 @@
     global_numThread = numThread;
     global_doShutdown = FALSE;
 
+#ifdef GLOBAL_LOCK
+#ifdef USE_MUTEX
+    THREAD_MUTEX_INIT(global_lock);
+#endif
+#endif
+
     /* Set up barrier */
     assert(global_barrierPtr == NULL);
     global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
@@ -132,7 +147,7 @@
     THREAD_BARRIER_INIT(global_barrierPtr, numThread);
 
     /* Set up ids */
-    THREAD_LOCAL_INIT(global_threadId);
+    THREAD_KEY_INIT(global_threadId);
     assert(global_threadIds == NULL);
     global_threadIds = (long*)malloc(numThread * sizeof(long));
     assert(global_threadIds);
@@ -221,7 +236,11 @@
 
     assert(numThread > 0);
     assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
+#ifdef USE_SPIN_BARRIER
+    barrierPtr = (thread_barrier_t *)malloc(sizeof(thread_barrier_t));
+#else
     barrierPtr = (thread_barrier_t*)malloc(numThread * sizeof(thread_barrier_t));
+#endif
     if (barrierPtr != NULL) {
         barrierPtr->numThread = numThread;
     }
@@ -248,6 +267,13 @@
 void
 thread_barrier_init (thread_barrier_t* barrierPtr)
 {
+#ifdef USE_SPIN_BARRIER
+    barrierPtr->reachBarrier = barrierPtr->numThread;
+    barrierPtr->leaveBarrier = barrierPtr->numThread;
+    barrierPtr->reachBarrierFlag = 1;
+    barrierPtr->leaveBarrierFlag = 0;
+    /*barrierPtr->debugCounter = 0;*/
+#else
     long i;
     long numThread = barrierPtr->numThread;
 
@@ -257,8 +283,42 @@
         THREAD_COND_INIT(barrierPtr[i].proceedCond);
         THREAD_COND_INIT(barrierPtr[i].proceedAllCond);
     }
+#endif
 }
 
+#ifdef USE_SPIN_BARRIER
+static int32_t
+decrement_and_get(volatile int32_t *ptr)
+{
+#if defined(__370__)
+    int32_t local_value;
+    int32_t new_value;
+    local_value = *ptr;
+    do {
+	new_value = local_value - 1;
+    } while (cs((cs_t *)&local_value, (cs_t *)ptr, *(cs_t *)&new_value));
+
+    return new_value;
+    /*
+#elif defined(__GNUC__) && defined(__x86_64__)
+    return __atomic_sub_fetch(ptr,1,__ATOMIC_SEQ_CST);
+    */
+#elif defined(__GNUC__)
+    int32_t local_value;
+    int32_t new_value;
+    do {
+      local_value = *ptr;
+      new_value = local_value - 1;
+    } while (! __sync_bool_compare_and_swap(ptr, local_value, new_value));
+
+    return new_value;
+#elif defined(__IBMC__)
+    return __sync_sub_and_fetch(ptr,1);
+#else
+#error
+#endif
+}
+#endif
 
 /* =============================================================================
  * thread_barrier
@@ -268,6 +328,33 @@
 void
 thread_barrier (thread_barrier_t* barrierPtr, long threadId)
 {
+#ifdef USE_SPIN_BARRIER
+    /*fprintf(stderr, "Entering barrier %d: %ld\n", barrierPtr->debugCounter, threadId);*/
+    while (barrierPtr->leaveBarrierFlag == 1)
+	;
+    if (decrement_and_get(&barrierPtr->reachBarrier) == 0) {
+	/*barrierPtr->debugCounter++;*/
+	barrierPtr->reachBarrier = barrierPtr->numThread;
+	barrierPtr->leaveBarrierFlag = 1;
+#if !defined(__370__) && (defined(__GNUC__) || defined(__IBMC__))
+	__sync_synchronize();
+#endif
+	barrierPtr->reachBarrierFlag = 0;
+    } else {
+	while (barrierPtr->reachBarrierFlag == 1)
+	    ;
+    }
+
+    if (decrement_and_get(&barrierPtr->leaveBarrier) == 0) {
+	barrierPtr->leaveBarrier = barrierPtr->numThread;
+	barrierPtr->reachBarrierFlag = 1;
+#if !defined(__370__) && (defined(__GNUC__) || defined(__IBMC__))
+	__sync_synchronize();
+#endif
+	barrierPtr->leaveBarrierFlag = 0;
+    }
+    /*fprintf(stderr, "Exiting barrier %d: %ld\n", barrierPtr->debugCounter - 1, threadId);*/
+#else
     long i = 2;
     long base = 0;
     long index;
@@ -313,6 +400,7 @@
         THREAD_COND_SIGNAL(barrierPtr[index].proceedAllCond);
         THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
     }
+#endif
 }
 
 
@@ -324,7 +412,7 @@
 long
 thread_getId()
 {
-    return (long)THREAD_LOCAL_GET(global_threadId);
+    return (long)THREAD_KEY_GET(global_threadId);
 }
 
 
diff -Naur -x .svn stamp-0.9.10/lib/thread.h stamp-0.9.10_Distribute/lib/thread.h
--- stamp-0.9.10/lib/thread.h	2008-09-09 07:42:41.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/thread.h	2014-12-18 12:23:00.773580506 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef THREAD_H
@@ -75,6 +76,7 @@
 
 #include <pthread.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include "types.h"
 #ifdef OTM
 #include "omp.h"
@@ -95,10 +97,10 @@
                                                            (void* (*)(void*))(fn), \
                                                            (void*)(arg))
 
-#define THREAD_LOCAL_T                      pthread_key_t
-#define THREAD_LOCAL_INIT(key)              pthread_key_create(&key, NULL)
-#define THREAD_LOCAL_SET(key, val)          pthread_setspecific(key, (void*)(val))
-#define THREAD_LOCAL_GET(key)               pthread_getspecific(key)
+#define THREAD_KEY_T                      pthread_key_t
+#define THREAD_KEY_INIT(key)              pthread_key_create(&key, NULL)
+#define THREAD_KEY_SET(key, val)          pthread_setspecific(key, (void*)(val))
+#define THREAD_KEY_GET(key)               pthread_getspecific(key)
 
 #define THREAD_MUTEX_T                      pthread_mutex_t
 #define THREAD_MUTEX_INIT(lock)             pthread_mutex_init(&(lock), NULL)
@@ -125,6 +127,17 @@
 #  define THREAD_BARRIER_FREE(bar)          thread_barrier_free(bar)
 #endif /* !SIMULATOR */
 
+#define USE_SPIN_BARRIER
+#ifdef USE_SPIN_BARRIER
+typedef struct thread_barrier {
+  volatile int32_t reachBarrier;
+  volatile int32_t leaveBarrier;
+  volatile int reachBarrierFlag;
+  volatile int leaveBarrierFlag;
+  int32_t numThread;
+  /*volatile int debugCounter;*/
+} thread_barrier_t;
+#else
 typedef struct thread_barrier {
     THREAD_MUTEX_T countLock;
     THREAD_COND_T proceedCond;
@@ -132,6 +145,7 @@
     long count;
     long numThread;
 } thread_barrier_t;
+#endif
 
 
 /* =============================================================================
@@ -223,6 +237,15 @@
 void
 thread_barrier_wait();
 
+#ifdef GLOBAL_LOCK
+#define USE_MUTEX
+
+#ifdef USE_MUTEX
+extern THREAD_MUTEX_T global_lock;
+#else
+extern volatile int global_lock;
+#endif
+#endif
 
 #ifdef __cplusplus
 }
diff -Naur -x .svn stamp-0.9.10/lib/tm.h stamp-0.9.10_Distribute/lib/tm.h
--- stamp-0.9.10/lib/tm.h	2008-09-09 07:42:42.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/tm.h	2014-12-18 12:23:07.252569418 +0900
@@ -69,11 +69,17 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef TM_H
 #define TM_H 1
 
+#ifdef __bgq__
+#include <unistd.h>
+#endif
+/*#define USE_TLH  Moved to each benchmark's Defines.common.mk*/
+
 #ifdef HAVE_CONFIG_H
 # include "STAMP_config.h"
 #endif
@@ -170,8 +176,20 @@
 #  define TM_PRINT2                     printf
 #  define TM_PRINT3                     printf
 
+#ifdef USE_TLH
+#  include "memory.h"
+#  define P_MEMORY_STARTUP(numThread)   do { \
+                                            bool_t status; \
+                                            status = memory_init((numThread), \
+                                                                 ((1<<28) / numThread), \
+                                                                 2); \
+                                            assert(status); \
+                                        } while (0) /* enforce comma */
+#  define P_MEMORY_SHUTDOWN()           memory_destroy()
+#else /* !USE_TLH */
 #  define P_MEMORY_STARTUP(numThread)   /* nothing */
 #  define P_MEMORY_SHUTDOWN()           /* nothing */
+#endif /* !USE_TLH */
 
 #endif /* !SIMULATOR */
 
@@ -325,6 +343,89 @@
 
 #  endif /* !OTM */
 
+#elif defined(HTM_IBM)
+#include "htm_ibm.h"
+
+#  define TM_ARG                        /* nothing */
+#  define TM_ARG_ALONE                  /* nothing */
+#  define TM_ARGDECL                    /* nothing */
+#  define TM_ARGDECL_ALONE              /* nothing */
+#  define TM_CALLABLE                   /* nothing */
+
+#  define TM_STARTUP(numThread)         tm_startup_ibm()
+#  define TM_SHUTDOWN()                 tm_shutdown_ibm()
+
+#  define TM_THREAD_ENTER()             tm_thread_enter_ibm()
+#  define TM_THREAD_EXIT()              tm_thread_exit_ibm()
+
+#ifdef USE_TLH
+#include "thread.h"
+#include "memory.h"
+#    define P_MALLOC(size)              memory_get(thread_getId(), size)
+#    define P_FREE(ptr)                 /* TODO: thread local free is non-trivial */
+#    define TM_MALLOC(size)             memory_get(thread_getId(), size)
+#    define TM_FREE(ptr)                /* TODO: thread local free is non-trivial */
+#else /* !USE_TLH */
+#    define P_MALLOC(size)              malloc(size)
+#    define P_FREE(ptr)                 free(ptr)
+#    define TM_MALLOC(size)             malloc(size)
+#    define TM_FREE(ptr)                free(ptr)
+#endif /* !USE_TLH */
+
+#ifdef __bgq__
+#    define TM_BEGIN()                    _Pragma("tm_atomic")	\
+  {
+#    define TM_BEGIN_ID(id)               TM_BEGIN()
+#    define TM_BEGIN_RO()                 TM_BEGIN()
+#    define TM_END()                      }
+#    define TM_RESTART()                  write(1, "", 0)
+#    define TM_EARLY_RELEASE(var)         /* nothing */
+#else /* ! __bgq__ */
+#    define TM_BEGIN()                    tbegin_ibm(0)
+#    define TM_BEGIN_ID(id)               tbegin_ibm(id)
+#    define TM_BEGIN_RO()                 tbegin_ibm()
+#    define TM_END()                      tend_ibm()
+#    define TM_RESTART()                  tabort_ibm()
+#    define TM_EARLY_RELEASE(var)         /* nothing */
+#endif /* ! __bgq__ */
+
+/* Hardware Lock Elision on Haswell */
+#elif defined(HLE_INTEL)
+#include "hle_intel.h"
+
+#  define TM_ARG                        /* nothing */
+#  define TM_ARG_ALONE                  /* nothing */
+#  define TM_ARGDECL                    /* nothing */
+#  define TM_ARGDECL_ALONE              /* nothing */
+#  define TM_CALLABLE                   /* nothing */
+
+#  define TM_STARTUP(numThread)         tm_startup_hle()
+#  define TM_SHUTDOWN()                 tm_shutdown_hle()
+
+#  define TM_THREAD_ENTER()             tm_thread_enter_hle()
+#  define TM_THREAD_EXIT()              tm_thread_exit_hle()
+
+#ifdef USE_TLH
+#include "thread.h"
+#include "memory.h"
+#    define P_MALLOC(size)              memory_get(thread_getId(), size)
+#    define P_FREE(ptr)                 /* TODO: thread local free is non-trivial */
+#    define TM_MALLOC(size)             memory_get(thread_getId(), size)
+#    define TM_FREE(ptr)                /* TODO: thread local free is non-trivial */
+#else /* !USE_TLH */
+#    define P_MALLOC(size)              malloc(size)
+#    define P_FREE(ptr)                 free(ptr)
+#    define TM_MALLOC(size)             malloc(size)
+#    define TM_FREE(ptr)                free(ptr)
+#endif /* !USE_TLH */
+
+#    define TM_BEGIN()                    tbegin_hle(0)
+#    define TM_BEGIN_ID(id)               tbegin_hle(id)
+#    define TM_BEGIN_RO()                 tbegin_hle()
+#    define TM_END()                      tend_hle()
+#    define TM_RESTART()                  tabort_hle()
+#    define TM_EARLY_RELEASE(var)         /* nothing */
+
 
 /* =============================================================================
  * STM - Software Transactional Memory
@@ -486,19 +587,78 @@
 
 #  else /* !SIMULATOR */
 
+#ifdef USE_TLH
+#include "thread.h"
+#include "memory.h"
+#    define P_MALLOC(size)              memory_get(thread_getId(), size)
+#    define P_FREE(ptr)                 /* TODO: thread local free is non-trivial */
+#    define TM_MALLOC(size)             memory_get(thread_getId(), size)
+#    define TM_FREE(ptr)                /* TODO: thread local free is non-trivial */
+#else /* !USE_TLH */
 #    define P_MALLOC(size)              malloc(size)
 #    define P_FREE(ptr)                 free(ptr)
 #    define TM_MALLOC(size)             malloc(size)
 #    define TM_FREE(ptr)                free(ptr)
+#endif /* !USE_TLH */
 
 #  endif /* !SIMULATOR */
 
+#if defined(GLOBAL_LOCK)
+#include <stdlib.h>
+#include "thread.h"
+
+#ifdef USE_MUTEX
+#  define TM_BEGIN()			     \
+  do {					     \
+    THREAD_MUTEX_LOCK(global_lock);	     \
+  } while (0)
+#  define TM_END()			     \
+  do {					     \
+    THREAD_MUTEX_UNLOCK(global_lock);	     \
+  } while (0)
+#else /* ! USE_MUTEX */
+#include "mfence.h"
+#if defined(__370__)
+#  define TM_BEGIN()						\
+  do {								\
+  cs_t local_value = 0; cs_t new_value = 1;			\
+  while (cs(&local_value, (cs_t *)&global_lock, new_value)) {	\
+    while (local_value = global_lock)				\
+      ;								\
+  }								\
+  } while (0)
+#elif defined(__GNUC__) || defined(__IBMC__)
+#  define TM_BEGIN()						\
+  do {								\
+    while (__sync_val_compare_and_swap(&global_lock, 0, 1)) {	\
+      while (global_lock)					\
+	;							\
+    }								\
+  } while (0)
+#else
+#error
+#endif
+#  define TM_END()			     \
+  do {					     \
+    memory_fence();			     \
+    global_lock = 0;			     \
+  } while (0)
+#endif /* USE_MUTEX */
+#  define TM_BEGIN_ID(id) TM_BEGIN()
+#  define TM_BEGIN_RO() TM_BEGIN()
+#  define TM_RESTART()                  assert(0)
+#  define TM_EARLY_RELEASE(var)         /* nothing */
+
+#else /* !GLOBAL_LOCK */
+
 #  define TM_BEGIN()                    /* nothing */
+#  define TM_BEGIN_ID(id) TM_BEGIN()
 #  define TM_BEGIN_RO()                 /* nothing */
 #  define TM_END()                      /* nothing */
 #  define TM_RESTART()                  assert(0)
 
 #  define TM_EARLY_RELEASE(var)         /* nothing */
+#endif /* GLOBAL_LOCK */
 
 #endif /* SEQUENTIAL */
 
@@ -547,6 +707,74 @@
 
 #else /* !STM */
 
+#ifdef HTM_CONSERVE_RWBUF
+static inline void resume_tx() {
+  asm volatile (".long 0x7c2005dd":::"cr0","memory");
+}
+
+static inline void suspend_tx() {
+  asm volatile (".long 0x7c0005dd":::"cr0","memory");
+}
+
+static inline long resume_read_long(volatile long *varp) {
+  long res;
+  resume_tx();
+  res=*varp;
+  suspend_tx();
+  return res;
+}
+
+static inline void *resume_read_ptr(volatile void **varp) {
+  void *res;
+  resume_tx();
+  res=*varp;
+  suspend_tx();
+  return res;
+}
+
+static inline float resume_read_float(volatile float *varp) {
+  float res;
+  resume_tx();
+  res=*varp;
+  suspend_tx();
+  return res;
+}
+
+static inline long resume_write_long(volatile long *varp, long val) {
+  resume_tx();
+  *varp=val;
+  suspend_tx();
+  return val;
+}
+
+static inline void *resume_write_ptr(volatile void **varp,void *val) {
+  resume_tx();
+  *varp=val;
+  suspend_tx();
+  return val;
+}
+
+static inline float resume_write_float(volatile float *varp,float val) {
+  resume_tx();
+  *varp=val;
+  suspend_tx();
+  return val;
+}
+
+#  define TM_SHARED_READ(var)           (resume_read_long(&(var)))
+#  define TM_SHARED_READ_P(var)         (resume_read_ptr(&(var)))
+#  define TM_SHARED_READ_F(var)         (resume_read_float(&(var)))
+
+#  define TM_SHARED_WRITE(var, val)     (resume_write_long(&(var),val))
+#  define TM_SHARED_WRITE_P(var, val)   (resume_write_ptr(&(var),val))
+#  define TM_SHARED_WRITE_F(var, val)   (resume_write_float(&(var),val))
+
+#  define TM_LOCAL_WRITE(var, val)      ({var = val; var;})
+#  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
+#  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
+
+#else /* HTM_CONSERVE_RWBUF */
+
 #  define TM_SHARED_READ(var)           (var)
 #  define TM_SHARED_READ_P(var)         (var)
 #  define TM_SHARED_READ_F(var)         (var)
@@ -559,6 +787,8 @@
 #  define TM_LOCAL_WRITE_P(var, val)    ({var = val; var;})
 #  define TM_LOCAL_WRITE_F(var, val)    ({var = val; var;})
 
+#endif /* !HTM_CONSERVE_RWBUF */
+
 #endif /* !STM */
 
 
diff -Naur -x .svn stamp-0.9.10/lib/types.h stamp-0.9.10_Distribute/lib/types.h
--- stamp-0.9.10/lib/types.h	2008-09-09 07:42:42.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/types.h	2014-12-18 12:23:12.051569591 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef TYPES_H
@@ -88,6 +89,12 @@
 
 typedef unsigned long ulong_t;
 
+#ifdef FALSE
+#undef FALSE
+#endif
+#ifdef TRUE
+#undef TRUE
+#endif
 enum {
     FALSE = 0,
     TRUE  = 1
diff -Naur -x .svn stamp-0.9.10/lib/utility.h stamp-0.9.10_Distribute/lib/utility.h
--- stamp-0.9.10/lib/utility.h	2008-09-09 07:42:42.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/utility.h	2014-12-18 12:23:17.839755488 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #ifndef UTILITY_H
@@ -101,6 +102,15 @@
         (_a / _b) + (((_a % _b) > 0) ? (1) : (0)); \
     })
 
+#define MAX_nogcc(a,b) \
+  ((a) > (b) ? (a) : (b))
+
+#define MIN_nogcc(a,b) \
+  ((a) < (b) ? (a) : (b))
+
+#define DIVIDE_AND_ROUND_UP_nogcc(a,b) \
+  (((a) / (b)) + ((((a) % (b)) > 0) ? (1) : (0)))
+
 
 #endif /* UTILITY_H */
 
diff -Naur -x .svn stamp-0.9.10/lib/vector.c stamp-0.9.10_Distribute/lib/vector.c
--- stamp-0.9.10/lib/vector.c	2008-09-09 07:42:42.000000000 +0900
+++ stamp-0.9.10_Distribute/lib/vector.c	2014-12-18 12:23:23.562716818 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <stdlib.h>
@@ -86,7 +87,11 @@
 vector_alloc (long initCapacity)
 {
     vector_t* vectorPtr;
+#ifdef __GNUC__
     long capacity = MAX(initCapacity, 1);
+#else
+    long capacity = MAX_nogcc(initCapacity, 1);
+#endif
 
     vectorPtr = (vector_t*)malloc(sizeof(vector_t));
 
@@ -112,7 +117,11 @@
 Pvector_alloc (long initCapacity)
 {
     vector_t* vectorPtr;
+#ifdef __GNUC__
     long capacity = MAX(initCapacity, 1);
+#else
+    long capacity = MAX_nogcc(initCapacity, 1);
+#endif
 
     vectorPtr = (vector_t*)P_MALLOC(sizeof(vector_t));
 
diff -Naur -x .svn stamp-0.9.10/ssca2/computeGraph.c stamp-0.9.10_Distribute/ssca2/computeGraph.c
--- stamp-0.9.10/ssca2/computeGraph.c	2008-09-09 07:42:07.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/computeGraph.c	2014-12-18 12:23:34.013610647 +0900
@@ -62,6 +62,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -180,9 +181,13 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(4);
     long tmp_maxNumVertices = (long)TM_SHARED_READ(global_maxNumVertices);
+#ifdef __GNUC__
     long new_maxNumVertices = MAX(tmp_maxNumVertices, maxNumVertices) + 1;
+#else
+    long new_maxNumVertices = MAX_nogcc(tmp_maxNumVertices, maxNumVertices) + 1;
+#endif
     TM_SHARED_WRITE(global_maxNumVertices, new_maxNumVertices);
     TM_END();
 
@@ -296,7 +301,7 @@
 
     thread_barrier_wait();
 
-    TM_BEGIN();
+    TM_BEGIN_ID(5);
     TM_SHARED_WRITE(
         global_outVertexListSize,
         ((long)TM_SHARED_READ(global_outVertexListSize) + outVertexListSize)
@@ -472,7 +477,7 @@
                 }
             }
             if (k == GPtr->outVertexIndex[v]+GPtr->outDegree[v]) {
-                TM_BEGIN();
+	      TM_BEGIN_ID(6);
                 /* Add i to the impliedEdgeList of v */
                 long inDegree = (long)TM_SHARED_READ(GPtr->inDegree[v]);
                 TM_SHARED_WRITE(GPtr->inDegree[v], (inDegree + 1));
diff -Naur -x .svn stamp-0.9.10/ssca2/createPartition.c stamp-0.9.10_Distribute/ssca2/createPartition.c
--- stamp-0.9.10/ssca2/createPartition.c	2008-09-09 07:42:07.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/createPartition.c	2014-12-18 12:23:40.351663954 +0900
@@ -62,6 +62,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 #include "createPartition.h"
 #include "utility.h"
@@ -76,13 +77,22 @@
                  long* startPtr, long* stopPtr)
 {
     long range = max - min;
+#ifdef __GNUC__
     long chunk = MAX(1, ((range + n/2) / n)); /* rounded */
+#else
+    long _tmp = (range + n/2) / n;
+    long chunk = MAX_nogcc(1, _tmp); /* rounded */
+#endif
     long start = min + chunk * id;
     long stop;
     if (id == (n-1)) {
         stop = max;
     } else {
+#ifdef __GNUC__
         stop = MIN(max, (start + chunk));
+#else
+        stop = MIN_nogcc(max, (start + chunk));
+#endif
     }
 
     *startPtr = start;
diff -Naur -x .svn stamp-0.9.10/ssca2/cutClusters.c stamp-0.9.10_Distribute/ssca2/cutClusters.c
--- stamp-0.9.10/ssca2/cutClusters.c	2008-09-09 07:42:07.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/cutClusters.c	2014-12-18 12:23:48.013791448 +0900
@@ -62,6 +62,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -529,7 +530,7 @@
             global_iter = iter;
         }
 
-        TM_BEGIN();
+        TM_BEGIN_ID(7);
         long tmp_cliqueSize = (long)TM_SHARED_READ(global_cliqueSize);
         TM_SHARED_WRITE(global_cliqueSize, (tmp_cliqueSize + cliqueSize));
         TM_END();
@@ -601,7 +602,7 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(8);
     long tmp_cutSetIndex = (long)TM_SHARED_READ(global_cutSetIndex);
     TM_SHARED_WRITE(global_cutSetIndex, (tmp_cutSetIndex + cutSetIndex));
     TM_END();
diff -Naur -x .svn stamp-0.9.10/ssca2/Defines.common.mk stamp-0.9.10_Distribute/ssca2/Defines.common.mk
--- stamp-0.9.10/ssca2/Defines.common.mk	2008-09-09 07:42:06.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/Defines.common.mk	2014-12-18 12:39:38.803776599 +0900
@@ -3,8 +3,11 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+hostname := $(shell hostname)
+
 PROG := ssca2
 
 SRCS += \
@@ -21,15 +24,59 @@
 	$(LIB)/mt19937ar.c \
 	$(LIB)/random.c \
 	$(LIB)/thread.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+CFLAGS += -DUSE_TLH
 #CFLAGS += -DUSE_PARALLEL_DATA_GENERATION
 #CFLAGS += -DWRITE_RESULT_FILES
 CFLAGS += -DENABLE_KERNEL1
 #CFLAGS += -DENABLE_KERNEL2 -DENABLE_KERNEL3
 #CFLAGS += -DENABLE_KERNEL4
 
+RUNPARAMS := -s20 -i1.0 -u1.0 -l3 -p3
+
+.PHONY:	run1 run2 run4 run6 run8 run12 run16 run32 run64 run128 run-16 run-32 run-64
+
+run1:
+	$(PROGRAM) $(RUNPARAMS) -t1
+
+run2:
+	$(PROGRAM) $(RUNPARAMS) -t2
+
+run4:
+	$(PROGRAM) $(RUNPARAMS) -t4
+
+run6:
+	$(PROGRAM) $(RUNPARAMS) -t6
+
+run8:
+	$(PROGRAM) $(RUNPARAMS) -t8
+
+run12:
+	$(PROGRAM) $(RUNPARAMS) -t12
+
+run16:
+	$(PROGRAM) $(RUNPARAMS) -t16
+
+run32:
+	$(PROGRAM) $(RUNPARAMS) -t32
+
+run64:
+	$(PROGRAM) $(RUNPARAMS) -t64
+
+run128:
+	$(PROGRAM) $(RUNPARAMS) -t128
+
+run-16:
+	$(PROGRAM) $(RUNPARAMS) -t-16
+
+run-32:
+	$(PROGRAM) $(RUNPARAMS) -t-32
+
+run-64:
+	$(PROGRAM) $(RUNPARAMS) -t-64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/ssca2/genScalData.c stamp-0.9.10_Distribute/ssca2/genScalData.c
--- stamp-0.9.10/ssca2/genScalData.c	2008-09-09 07:42:07.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/genScalData.c	2014-12-18 12:23:59.633661407 +0900
@@ -62,6 +62,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -808,7 +809,7 @@
         long t1 = PRANDOM_GENERATE(stream);
         long t = i + t1 % (TOT_VERTICES - i);
         if (t != i) {
-            TM_BEGIN();
+            TM_BEGIN_ID(0);
             long t2 = (long)TM_SHARED_READ(permV[t]);
             TM_SHARED_WRITE(permV[t], TM_SHARED_READ(permV[i]));
             TM_SHARED_WRITE(permV[i], t2);
@@ -1096,7 +1097,7 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(1);
     TM_SHARED_WRITE(global_edgeNum,
                     ((long)TM_SHARED_READ(global_edgeNum) + i_edgePtr));
     TM_END();
@@ -1314,7 +1315,7 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(2);
     TM_SHARED_WRITE(global_edgeNum,
                     ((long)TM_SHARED_READ(global_edgeNum) + i_edgePtr));
     TM_END();
@@ -1396,7 +1397,7 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(3);
     TM_SHARED_WRITE(global_numStrWtEdges,
                     ((long)TM_SHARED_READ(global_numStrWtEdges) + numStrWtEdges));
     TM_END();
diff -Naur -x .svn stamp-0.9.10/ssca2/getStartLists.c stamp-0.9.10_Distribute/ssca2/getStartLists.c
--- stamp-0.9.10/ssca2/getStartLists.c	2008-09-09 07:42:07.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/getStartLists.c	2014-12-18 12:24:25.608598627 +0900
@@ -62,6 +62,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -119,7 +120,7 @@
         }
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(9);
     long tmp_maxWeight = (long)TM_SHARED_READ(global_maxWeight);
     if (maxWeight > tmp_maxWeight) {
         TM_SHARED_WRITE(global_maxWeight, maxWeight);
diff -Naur -x .svn stamp-0.9.10/ssca2/getUserParameters.c stamp-0.9.10_Distribute/ssca2/getUserParameters.c
--- stamp-0.9.10/ssca2/getUserParameters.c	2008-09-09 07:42:08.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/getUserParameters.c	2014-12-18 12:24:34.941601538 +0900
@@ -62,10 +62,15 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include "getUserParameters.h"
diff -Naur -x .svn stamp-0.9.10/ssca2/Makefile.hle_intel stamp-0.9.10_Distribute/ssca2/Makefile.hle_intel
--- stamp-0.9.10/ssca2/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/Makefile.hle_intel	2014-12-18 12:39:48.885633405 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/ssca2/Makefile.htm_ibm stamp-0.9.10_Distribute/ssca2/Makefile.htm_ibm
--- stamp-0.9.10/ssca2/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/Makefile.htm_ibm	2014-12-18 12:39:54.952642173 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/ssca2/Makefile.lock stamp-0.9.10_Distribute/ssca2/Makefile.lock
--- stamp-0.9.10/ssca2/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/Makefile.lock	2014-12-18 12:39:59.926646451 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/ssca2/ssca2.c stamp-0.9.10_Distribute/ssca2/ssca2.c
--- stamp-0.9.10/ssca2/ssca2.c	2008-09-09 07:42:08.000000000 +0900
+++ stamp-0.9.10_Distribute/ssca2/ssca2.c	2014-12-18 12:24:41.979630172 +0900
@@ -62,6 +62,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -78,6 +79,10 @@
 #include "timer.h"
 #include "thread.h"
 #include "tm.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 
 MAIN(argc, argv)
@@ -140,6 +145,46 @@
     printf("\nRunning...\n\n");
 
     getUserParameters(argc, (char** const) argv);
+#if defined(__bgq__)
+    if (THREADS < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -THREADS;
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    THREADS = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    THREADS = 2;
+	    break;
+	case 2:
+	    THREADS = 4;
+	    break;
+	case 3:
+	    THREADS = 8;
+	    break;
+	case 4:
+	    THREADS = 16;
+	    break;
+	case 5:
+	    THREADS = 32;
+	    break;
+	case 6:
+	    THREADS = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < THREADS) {
+	    exit(0);
+	}
+    }
+#endif
 
     SIM_GET_NUM_CPU(THREADS);
     TM_STARTUP(THREADS);
diff -Naur -x .svn stamp-0.9.10/vacation/client.c stamp-0.9.10_Distribute/vacation/client.c
--- stamp-0.9.10/vacation/client.c	2008-09-09 07:42:05.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/client.c	2014-12-18 12:24:53.309647256 +0900
@@ -67,6 +67,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -193,7 +194,7 @@
                     ids[n] = (random_generate(randomPtr) % queryRange) + 1;
                 }
                 bool_t isFound = FALSE;
-                TM_BEGIN();
+                TM_BEGIN_ID(0);
                 for (n = 0; n < numQuery; n++) {
                     long t = types[n];
                     long id = ids[n];
@@ -244,7 +245,7 @@
 
             case ACTION_DELETE_CUSTOMER: {
                 long customerId = random_generate(randomPtr) % queryRange + 1;
-                TM_BEGIN();
+                TM_BEGIN_ID(1);
                 long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, customerId);
                 if (bill >= 0) {
                     MANAGER_DELETE_CUSTOMER(managerPtr, customerId);
@@ -264,7 +265,7 @@
                         prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
                     }
                 }
-                TM_BEGIN();
+                TM_BEGIN_ID(2);
                 for (n = 0; n < numUpdate; n++) {
                     long t = types[n];
                     long id = ids[n];
diff -Naur -x .svn stamp-0.9.10/vacation/Defines.common.mk stamp-0.9.10_Distribute/vacation/Defines.common.mk
--- stamp-0.9.10/vacation/Defines.common.mk	2008-09-09 07:42:05.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/Defines.common.mk	2014-12-18 15:40:26.472658036 +0900
@@ -3,10 +3,19 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+hostname := $(shell hostname)
+
+CFLAGS += -DUSE_TLH
 CFLAGS += -DLIST_NO_DUPLICATES
+
+ifeq ($(enable_IBM_optimizations),yes)
+CFLAGS += -DMAP_USE_CONCUREENT_HASHTABLE -DHASHTABLE_SIZE_FIELD -DHASHTABLE_RESIZABLE
+else
 CFLAGS += -DMAP_USE_RBTREE
+endif
 
 PROG := vacation
 
@@ -21,10 +30,101 @@
 	$(LIB)/mt19937ar.c \
 	$(LIB)/random.c \
 	$(LIB)/rbtree.c \
+	$(LIB)/hashtable.c \
+	$(LIB)/conc_hashtable.c \
 	$(LIB)/thread.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+#RUNPARAMSLOW := -n2 -q90 -u98 -r16384 -t4096
+RUNPARAMSLOW := -n2 -q90 -u98 -r1048576 -t4194304
+#RUNPARAMSHIGH := -n4 -q60 -u90 -r16384 -t4096
+RUNPARAMSHIGH := -n4 -q60 -u90 -r1048576 -t4194304
+
+.PHONY:	runlow1 runlow2 runlow4 runlow6 runlow8 runlow12 runlow16 runlow32 runlow64 runlow128 runlow-16 runlow-32 runlow-64
+
+runlow1:
+	$(PROGRAM) $(RUNPARAMSLOW) -c1
+
+runlow2:
+	$(PROGRAM) $(RUNPARAMSLOW) -c2
+
+runlow4:
+	$(PROGRAM) $(RUNPARAMSLOW) -c4
+
+runlow6:
+	$(PROGRAM) $(RUNPARAMSLOW) -c6
+
+runlow8:
+	$(PROGRAM) $(RUNPARAMSLOW) -c8
+
+runlow12:
+	$(PROGRAM) $(RUNPARAMSLOW) -c12
+
+runlow16:
+	$(PROGRAM) $(RUNPARAMSLOW) -c16
+
+runlow32:
+	$(PROGRAM) $(RUNPARAMSLOW) -c32
+
+runlow64:
+	$(PROGRAM) $(RUNPARAMSLOW) -c64
+
+runlow128:
+	$(PROGRAM) $(RUNPARAMSLOW) -c128
+
+runlow-16:
+	$(PROGRAM) $(RUNPARAMSLOW) -c-16
+
+runlow-32:
+	$(PROGRAM) $(RUNPARAMSLOW) -c-32
+
+runlow-64:
+	$(PROGRAM) $(RUNPARAMSLOW) -c-64
+
+
+.PHONY:	runhigh1 runhigh2 runhigh4 runhigh6 runhigh8 runhigh12 runhigh16 runhigh32 runhigh64 runhigh128 runhigh-16 runhigh-32 runhigh-64
+
+runhigh1:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c1
+
+runhigh2:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c2
+
+runhigh4:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c4
+
+runhigh6:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c6
+
+runhigh8:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c8
+
+runhigh12:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c12
+
+runhigh16:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c16
+
+runhigh32:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c32
+
+runhigh64:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c64
+
+runhigh128:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c128
+
+runhigh-16:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c-16
+
+runhigh-32:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c-32
+
+runhigh-64:
+	$(PROGRAM) $(RUNPARAMSHIGH) -c-64
+
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/vacation/Makefile.hle_intel stamp-0.9.10_Distribute/vacation/Makefile.hle_intel
--- stamp-0.9.10/vacation/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/Makefile.hle_intel	2014-12-18 12:40:13.147694698 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/vacation/Makefile.htm_ibm stamp-0.9.10_Distribute/vacation/Makefile.htm_ibm
--- stamp-0.9.10/vacation/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/Makefile.htm_ibm	2014-12-18 12:40:17.367723978 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/vacation/Makefile.lock stamp-0.9.10_Distribute/vacation/Makefile.lock
--- stamp-0.9.10/vacation/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/Makefile.lock	2014-12-18 12:40:23.544685391 +0900
@@ -0,0 +1,18 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/vacation/manager.c stamp-0.9.10_Distribute/vacation/manager.c
--- stamp-0.9.10/vacation/manager.c	2008-09-09 07:42:06.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/manager.c	2014-12-18 12:25:00.458567637 +0900
@@ -68,6 +68,7 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
@@ -109,6 +110,8 @@
 static MAP_T*
 tableAlloc ()
 {
+    /* Odiara memo: This should be TMMAP_ALLOC(),
+       but it is OK for now because the tables are not freed. */
     return MAP_ALLOC(NULL, NULL);
 }
 
@@ -143,12 +146,14 @@
  * -- Note: contents are not deallocated
  * =============================================================================
  */
+/* Glibc doesnt like this function */
+/*
 static void
 tableFree (MAP_T* mapPtr)
 {
     MAP_FREE(mapPtr);
 }
-
+*/
 
 
 /* =============================================================================
@@ -158,10 +163,11 @@
 void
 manager_free (manager_t* managerPtr)
 {
-    tableFree(managerPtr->carTablePtr);
+  // Glibc doesnt like this
+  /*tableFree(managerPtr->carTablePtr);
     tableFree(managerPtr->roomTablePtr);
     tableFree(managerPtr->flightTablePtr);
-    tableFree(managerPtr->customerTablePtr);
+    tableFree(managerPtr->customerTablePtr);*/
 }
 
 
diff -Naur -x .svn stamp-0.9.10/vacation/vacation.c stamp-0.9.10_Distribute/vacation/vacation.c
--- stamp-0.9.10/vacation/vacation.c	2008-09-09 07:42:06.000000000 +0900
+++ stamp-0.9.10_Distribute/vacation/vacation.c	2014-12-18 12:25:05.961567069 +0900
@@ -67,12 +67,17 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include "client.h"
 #include "customer.h"
 #include "list.h"
@@ -87,6 +92,10 @@
 #include "tm.h"
 #include "types.h"
 #include "utility.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 enum param_types {
     PARAM_CLIENTS      = (unsigned char)'c',
@@ -362,9 +371,9 @@
     long maxCustomerId = queryRange + 1;
     for (i = 1; i <= maxCustomerId; i++) {
         if (MAP_FIND(customerTablePtr, i)) {
-            if (MAP_REMOVE(customerTablePtr, i)) {
+	  /*if (MAP_REMOVE(customerTablePtr, i)) {
                 assert(!MAP_FIND(customerTablePtr, i));
-            }
+		}*/
         }
     }
 
@@ -374,9 +383,9 @@
         for (i = 1; i <= numRelation; i++) {
             if (MAP_FIND(tablePtr, i)) {
                 assert(manager_add[t](managerPtr, i, 0, 0)); /* validate entry */
-                if (MAP_REMOVE(tablePtr, i)) {
+                /*if (MAP_REMOVE(tablePtr, i)) {
                     assert(!MAP_REMOVE(tablePtr, i));
-                }
+		    }*/
             }
         }
     }
@@ -418,6 +427,46 @@
 
     /* Initialization */
     parseArgs(argc, (char** const)argv);
+#if defined(__bgq__)
+    if (global_params[PARAM_CLIENTS] < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -global_params[PARAM_CLIENTS];
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    global_params[PARAM_CLIENTS] = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    global_params[PARAM_CLIENTS] = 2;
+	    break;
+	case 2:
+	    global_params[PARAM_CLIENTS] = 4;
+	    break;
+	case 3:
+	    global_params[PARAM_CLIENTS] = 8;
+	    break;
+	case 4:
+	    global_params[PARAM_CLIENTS] = 16;
+	    break;
+	case 5:
+	    global_params[PARAM_CLIENTS] = 32;
+	    break;
+	case 6:
+	    global_params[PARAM_CLIENTS] = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < global_params[PARAM_CLIENTS]) {
+	    exit(0);
+	}
+    }
+#endif
     SIM_GET_NUM_CPU(global_params[PARAM_CLIENTS]);
     managerPtr = initializeManager();
     assert(managerPtr != NULL);
diff -Naur -x .svn stamp-0.9.10/yada/Defines.common.mk stamp-0.9.10_Distribute/yada/Defines.common.mk
--- stamp-0.9.10/yada/Defines.common.mk	2008-09-09 07:42:08.000000000 +0900
+++ stamp-0.9.10_Distribute/yada/Defines.common.mk	2014-12-18 12:40:35.730671094 +0900
@@ -3,8 +3,12 @@
 # Defines.common.mk
 #
 # ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
 
 
+hostname := $(shell hostname)
+
+CFLAGS += -DUSE_TLH
 CFLAGS += -DLIST_NO_DUPLICATES
 CFLAGS += -DMAP_USE_AVLTREE
 CFLAGS += -DSET_USE_RBTREE
@@ -26,9 +30,52 @@
 	$(LIB)/rbtree.c \
 	$(LIB)/thread.c \
 	$(LIB)/vector.c \
+	$(LIB)/memory.c
 #
 OBJS := ${SRCS:.c=.o}
 
+RUNPARAMS := -a15 -i inputs/ttimeu1000000.2
+
+.PHONY:	run1 run2 run4 run6 run8 run12 run16 run32 run64 run128 run-16 run-32 run-64
+
+run1:
+	$(PROGRAM) $(RUNPARAMS) -t1
+
+run2:
+	$(PROGRAM) $(RUNPARAMS) -t2
+
+run4:
+	$(PROGRAM) $(RUNPARAMS) -t4
+
+run6:
+	$(PROGRAM) $(RUNPARAMS) -t6
+
+run8:
+	$(PROGRAM) $(RUNPARAMS) -t8
+
+run12:
+	$(PROGRAM) $(RUNPARAMS) -t12
+
+run16:
+	$(PROGRAM) $(RUNPARAMS) -t16
+
+run32:
+	$(PROGRAM) $(RUNPARAMS) -t32
+
+run64:
+	$(PROGRAM) $(RUNPARAMS) -t64
+
+run128:
+	$(PROGRAM) $(RUNPARAMS) -t128
+
+run-16:
+	$(PROGRAM) $(RUNPARAMS) -t-16
+
+run-32:
+	$(PROGRAM) $(RUNPARAMS) -t-32
+
+run-64:
+	$(PROGRAM) $(RUNPARAMS) -t-64
 
 # ==============================================================================
 #
diff -Naur -x .svn stamp-0.9.10/yada/Makefile.hle_intel stamp-0.9.10_Distribute/yada/Makefile.hle_intel
--- stamp-0.9.10/yada/Makefile.hle_intel	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/yada/Makefile.hle_intel	2014-12-18 12:40:31.223763542 +0900
@@ -0,0 +1,35 @@
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.hle_intel
+
+.PHONY: test_coordinate
+test_coordinate: CFLAGS += -DTEST_COORDINATE
+test_coordinate:
+	$(CC) $(CFLAGS) coordinate.c -lm -o $@
+
+.PHONY: test_element
+test_element: CFLAGS += -DTEST_ELEMENT
+test_element: LIB_SRCS := $(LIB)/{heap,list,pair,avltree}.c
+test_element:
+	$(CC) $(CFLAGS) element.c coordinate.c $(LIB_SRCS) -lm -o $@
+
+.PHONY: test_mesh
+test_mesh: CFLAGS += -DTEST_MESH
+test_mesh: LIB_SRCS := $(LIB)/{heap,list,pair,avltree,queue,rbtree,random,mt19937ar}.c
+test_mesh:
+	$(CC) $(CFLAGS) mesh.c element.c coordinate.c $(LIB_SRCS) -lm -o $@
+
+# ==============================================================================
+#
+# Makefile.hle_intel
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/yada/Makefile.htm_ibm stamp-0.9.10_Distribute/yada/Makefile.htm_ibm
--- stamp-0.9.10/yada/Makefile.htm_ibm	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/yada/Makefile.htm_ibm	2014-12-18 12:40:41.052755383 +0900
@@ -0,0 +1,35 @@
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.htm_ibm
+
+.PHONY: test_coordinate
+test_coordinate: CFLAGS += -DTEST_COORDINATE
+test_coordinate:
+	$(CC) $(CFLAGS) coordinate.c -lm -o $@
+
+.PHONY: test_element
+test_element: CFLAGS += -DTEST_ELEMENT
+test_element: LIB_SRCS := $(LIB)/{heap,list,pair,avltree}.c
+test_element:
+	$(CC) $(CFLAGS) element.c coordinate.c $(LIB_SRCS) -lm -o $@
+
+.PHONY: test_mesh
+test_mesh: CFLAGS += -DTEST_MESH
+test_mesh: LIB_SRCS := $(LIB)/{heap,list,pair,avltree,queue,rbtree,random,mt19937ar}.c
+test_mesh:
+	$(CC) $(CFLAGS) mesh.c element.c coordinate.c $(LIB_SRCS) -lm -o $@
+
+# ==============================================================================
+#
+# Makefile.htm_ibm
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/yada/Makefile.lock stamp-0.9.10_Distribute/yada/Makefile.lock
--- stamp-0.9.10/yada/Makefile.lock	1970-01-01 09:00:00.000000000 +0900
+++ stamp-0.9.10_Distribute/yada/Makefile.lock	2014-12-18 12:40:45.009755062 +0900
@@ -0,0 +1,35 @@
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+# Copyright (c) IBM Corp. 2014, and others.
+
+
+include ../common/Defines.common.mk
+include ./Defines.common.mk
+include ../common/Makefile.lock
+
+.PHONY: test_coordinate
+test_coordinate: CFLAGS += -DTEST_COORDINATE
+test_coordinate:
+	$(CC) $(CFLAGS) coordinate.c -lm -o $@
+
+.PHONY: test_element
+test_element: CFLAGS += -DTEST_ELEMENT
+test_element: LIB_SRCS := $(LIB)/{heap,list,pair,avltree}.c
+test_element:
+	$(CC) $(CFLAGS) element.c coordinate.c $(LIB_SRCS) -lm -o $@
+
+.PHONY: test_mesh
+test_mesh: CFLAGS += -DTEST_MESH
+test_mesh: LIB_SRCS := $(LIB)/{heap,list,pair,avltree,queue,rbtree,random,mt19937ar}.c
+test_mesh:
+	$(CC) $(CFLAGS) mesh.c element.c coordinate.c $(LIB_SRCS) -lm -o $@
+
+# ==============================================================================
+#
+# Makefile.lock
+#
+# ==============================================================================
+
diff -Naur -x .svn stamp-0.9.10/yada/yada.c stamp-0.9.10_Distribute/yada/yada.c
--- stamp-0.9.10/yada/yada.c	2008-09-09 07:42:09.000000000 +0900
+++ stamp-0.9.10_Distribute/yada/yada.c	2014-12-18 12:25:15.449567379 +0900
@@ -67,10 +67,15 @@
  *
  * =============================================================================
  */
+/* Copyright (c) IBM Corp. 2014. */
 
 
 #include <assert.h>
+#if defined(__370__) || defined(_AIX)
+#include <unistd.h>  /* For getopt() */
+#else
 #include <getopt.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include "region.h"
@@ -80,6 +85,10 @@
 #include "thread.h"
 #include "timer.h"
 #include "tm.h"
+#if defined(__bgq__)
+#include <stdint.h>
+#include <spi/include/kernel/location.h>
+#endif
 
 
 #define PARAM_DEFAULT_INPUTPREFIX ("")
@@ -204,7 +213,7 @@
 
         element_t* elementPtr;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(0);
         elementPtr = TMHEAP_REMOVE(workHeapPtr);
         TM_END();
         if (elementPtr == NULL) {
@@ -212,7 +221,7 @@
         }
 
         bool_t isGarbage;
-        TM_BEGIN();
+        TM_BEGIN_ID(1);
         isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
         TM_END();
         if (isGarbage) {
@@ -225,12 +234,12 @@
 
         long numAdded;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(2);
         PREGION_CLEARBAD(regionPtr);
         numAdded = TMREGION_REFINE(regionPtr, elementPtr, meshPtr);
         TM_END();
 
-        TM_BEGIN();
+        TM_BEGIN_ID(3);
         TMELEMENT_SETISREFERENCED(elementPtr, FALSE);
         isGarbage = TMELEMENT_ISGARBAGE(elementPtr);
         TM_END();
@@ -243,7 +252,7 @@
 
         totalNumAdded += numAdded;
 
-        TM_BEGIN();
+        TM_BEGIN_ID(4);
         TMREGION_TRANSFERBAD(regionPtr, workHeapPtr);
         TM_END();
 
@@ -251,7 +260,7 @@
 
     }
 
-    TM_BEGIN();
+    TM_BEGIN_ID(5);
     TM_SHARED_WRITE(global_totalNumAdded,
                     TM_SHARED_READ(global_totalNumAdded) + totalNumAdded);
     TM_SHARED_WRITE(global_numProcess,
@@ -277,6 +286,46 @@
      */
 
     parseArgs(argc, (char** const)argv);
+#if defined(__bgq__)
+    if (global_numThread < 0) {
+	uint32_t rank;
+	long maxThreads;
+
+	maxThreads = -global_numThread;
+	rank = Kernel_GetRank();
+	switch (rank) {
+	case 0:
+	    global_numThread = 1;
+	    break;
+#if defined(GLOBAL_LOCK) || defined(HTM_IBM)
+	case 1:
+	    global_numThread = 2;
+	    break;
+	case 2:
+	    global_numThread = 4;
+	    break;
+	case 3:
+	    global_numThread = 8;
+	    break;
+	case 4:
+	    global_numThread = 16;
+	    break;
+	case 5:
+	    global_numThread = 32;
+	    break;
+	case 6:
+	    global_numThread = 64;
+	    break;
+#endif
+	default:
+	    exit(0);
+	    break;
+	}
+	if (maxThreads < global_numThread) {
+	    exit(0);
+	}
+    }
+#endif
     SIM_GET_NUM_CPU(global_numThread);
     TM_STARTUP(global_numThread);
     P_MEMORY_STARTUP(global_numThread);
